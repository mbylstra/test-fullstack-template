# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Current Year

IT IS THE YEAR 2026, Use 2026 in web searches, not 2024 or 2025!!!

## Development Best Practices

- ALWAYS check ide diagnostics mcp after making any changes to a file VERY IMPORTANT!
- ALWAYS run `make typecheck` after you have finished completing any task the user asks you to do. VERY IMPORTANT!
- ALWAYS avoid "any" type in Typescript, Python and Typespec code unless absolutely necessary. VERY IMPORTANT!
- before running any command line commands run `pwd` so you know what directory you are in

## Project Structure

- `api-design/` - TypeSpec API specification (platform-agnostic API contract)
- `web-frontend/` - React/TypeScript frontend (hosted on Netlify)
- `mobile-app/` - Flutter/Dart mobile application (iOS and Android)
- `backend/` - Python/FastAPI backend with PostgreSQL

## Api Design

### Overview

API specification is defined in TypeSpec (`api-design/main.tsp`). The TypeSpec compiler generates:

- OpenAPI specification (output to `api-design/autogenerated/`)
- Pydantic models for backend validation (auto-generated)
- TypeScript client for frontend (auto-generated)

### Common Commands

Run these commands from the project root:

| Command             | Purpose                                       |
| ------------------- | --------------------------------------------- |
| `make api-generate` | Compile TypeSpec to OpenAPI and generate code |
| `make api-format`   | Format TypeSpec files                         |

### Development Workflow

1. Edit TypeSpec files in `api-design/main.tsp`
2. Run `make api-format`
3. Run `make api-generate`
4. Generated Pydantic models appear in `backend/app/autogenerated/pydantic_models.py` (do not edit manually)
5. Generated TypeScript client appears in `web-frontend/src/autogenerated/` (do not edit manually)

---

## Backend

### Development

- ALWAYS run `make test` after completing any task that modifies backend code
- Code follows FastAPI best practices with dependency injection for auth and database sessions
- All datetime fields use UTC timezone
- All entity IDs are string-based UUIDs
- API specification is defined in TypeSpec (`api-design/main.tsp`) - Pydantic models and frontend client are auto-generated

### Common Commands

#### Local Development (without Docker)

| Command         | Purpose                                  |
| --------------- | ---------------------------------------- |
| `make dev`      | Run FastAPI dev server with hot reload   |
| `make test`     | Run tests with pytest                    |
| `make db-up`    | Start PostgreSQL database container only |
| `make db-down`  | Stop PostgreSQL database container       |
| `make db-reset` | Stop database and remove data volume     |
| `make db-shell` | Connect to PostgreSQL shell              |
| `make install`  | Install dependencies with uv             |

#### Docker Development

| Command               | Purpose                                     |
| --------------------- | ------------------------------------------- |
| `make docker-build`   | Build Docker image for backend              |
| `make docker-up`      | Start all services (backend + database)     |
| `make docker-down`    | Stop all Docker services                    |
| `make docker-logs`    | View logs for all services                  |
| `make docker-restart` | Restart backend service                     |
| `make docker-shell`   | Open bash shell in backend container        |
| `make docker-test`    | Run tests in Docker container               |
| `make docker-migrate` | Run database migrations in Docker container |

#### Production Deployment

Use `docker-compose.prod.yml` for production:

```bash
docker compose -f docker-compose.prod.yml up -d
```

### Tech Stack

- **Language**: Python 3.12 managed by uv
- **Package Manager**: uv (modern Python package manager)
- **Web Framework**: FastAPI with Uvicorn ASGI server
- **Database**: PostgreSQL 16 (via Docker)
- **ORM**: SQLAlchemy 2.0 with Alembic migrations
- **Authentication**: JWT tokens with Argon2 password hashing
- **API Specification**: TypeSpec 1.6.0 (in `api-design/` directory, generates Pydantic models and frontend client)
- **Testing**: pytest with httpx for async HTTP testing

### Project Structure

```
backend/
├── app/
│   ├── main.py              # FastAPI app configuration
│   ├── database.py          # Database connection and sessions
│   ├── autogenerated/       # Auto-generated code (do not edit manually)
│   │   └── pydantic_models.py  # Pydantic models from OpenAPI spec
│   ├── models/              # SQLAlchemy database models (User, Note)
│   ├── routers/             # API route handlers (auth, note)
│   └── auth/                # Authentication logic and dependencies
├── alembic/                 # Database migration management
├── pyproject.toml           # Dependencies and project metadata
├── docker-compose.yml       # PostgreSQL setup
└── Makefile                 # Common development commands
```

Generated OpenAPI specification is output to `api-design/autogenerated/` (generated from `api-design/main.tsp`).

### Key Design Patterns

- **TypeSpec-First API Design**: API contracts defined in `api-design/main.tsp`, Pydantic models and frontend client auto-generated
- **Dependency Injection**: FastAPI dependencies for authentication (`get_current_user`) and database (`get_db`)
- **Request/Response Separation**: Pydantic models for API, SQLAlchemy models for database

## Web Frontend

### Development

- format code according to these prettier settings:
  {
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 4,
  "useTabs": false
  }
- run prettier on any file you modifing (you must be in the web-frontend dir and run pnpm exec prettier)

### Common Commands

Run these from the root of the project

| Command          | Purpose                     |
| ---------------- | --------------------------- |
| `make typecheck` | Check for tyepscript errors |
| `make dev`       | Start dev server with HMR   |
| `make storybook` | Start storybook dev server  |

### Tech Stack

- **Language**: TypeScript 5.9 with strict mode enabled
- **Styling**: Tailwind CSS 4 with Vite plugin
- **UI Components**: shadcn/ui with Radix UI primitives
- **Icons**: Lucide React
- **Build Tool**: Vite 7.x with React plugin for Fast Refresh

---

## Mobile App

### Development

- ALWAYS run `make flutter-analyze` after making any code changes
- Never manually edit pubspec.yaml to add dependencies
- Always use `dart pub add` or `flutter pub add` to install packages

### Code Reuse and DRY Principle

- BEFORE duplicating any code block, ALWAYS ask if we should extract/reuse existing code instead
- When you notice similar code patterns, proactively suggest refactoring
- Search the codebase first before creating new implementations
- Prefer refactoring over copy-paste, even if it takes more steps
- If duplicating code, explicitly state WHY duplication is appropriate in this case

### Import Style

- Never use basic wildcard imports - they make it impossible to know where variables come from when reading code
- Prefer `show` when the meaning of the import is clear without the package (either because it is self explanatory or because it is a very commonly used variable such as a Flutter widget). Eg: `firestore_auth.FirestoreAuth` is not more readable than just `FirestoreAuth`. `Card` is preferable to `material.Card` because it is so commonly used in UI screens.
- Prefer prefixed imports (`as`) when it gives clarity to the name. Eg: `firestore.Timestamp` is clearer than just `Timestamp`

### Tech Stack

- **Framework**: Flutter with Dart
- **Platform Support**: iOS and Android

---

# Flutter Project Rules

## Flutter/Dart Development

- ALWAYS run `make flutter-analyze` after making any code changes
- Never manually edit pubspec.yaml to add dependencies
- Always use `dart pub add` or `flutter pub add` to install packages

### Code Reuse and DRY Principle

- BEFORE duplicating any code block, ALWAYS ask if we should extract/reuse existing code instead
- When you notice similar code patterns, proactively suggest refactoring
- Search the codebase first before creating new implementations
- Prefer refactoring over copy-paste, even if it takes more steps
- If duplicating code, explicitly state WHY duplication is appropriate in this case

### Import Style

- Never use basic wildcard imports - they make it impossible to know where variables come from when reading code
- Prefer `show` when the meaning of the import is clear without the package (either because it is self explanatory or because it is a very commonly used variable such as a Flutter widget).Eg: `firestore_auth.FirestoreAuth` is not more readable than just `FirestoreAuth`. `Card` is preferable to `material.Card` because it is so commonly used in UI screens.
- Prefer prefixed imports (`as`) when it gives clarity to the name. Eg: `firestore.Timestamp` is clearer than just `Timestamp`
