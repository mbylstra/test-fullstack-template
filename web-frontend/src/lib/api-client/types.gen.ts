// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'http://localhost:8000' | (string & {});
};

/**
 * Annoyingness level (0-4)
 */
export type Annoyingness = number;

/**
 * Request body for creating a new fun
 */
export type CreateFunRequest = {
    /**
     * The fun title
     */
    title: string;
    /**
     * Where to insert the fun (defaults to top)
     */
    position?: TodoPosition;
};

/**
 * Request body for creating a new habit
 */
export type CreateHabitRequest = {
    /**
     * The habit description
     */
    task: string;
    /**
     * Additional details stored as JSON
     */
    details?: {
        [key: string]: unknown;
    };
    /**
     * Current status of the habit (defaults to 'todo')
     */
    status?: TodoStatus;
    /**
     * Where to insert the habit (defaults to top)
     */
    position?: TodoPosition;
    /**
     * Importance level (0-5)
     */
    importance?: Importance;
    /**
     * Estimated time to complete
     */
    time_estimate?: TimeEstimate;
    /**
     * Annoyingness level (0-4)
     */
    annoyingness?: Annoyingness;
    /**
     * Whether the habit is committed (defaults to false)
     */
    committed?: boolean;
    /**
     * Whether the habit is atomic (defaults to false)
     */
    atomic?: boolean;
    /**
     * Whether the habit is infinitely divisible (defaults to false)
     */
    infinitely_divisible?: boolean;
    /**
     * Frequency kind for recurring habits
     * Constraints:
     * - If 'specific-days-per-week', daysOfWeek must be provided
     * - If 'multiple-days-per-week', numTimesPerWeek must be provided
     * - If 'specific-day-of-month', dayOfMonth must be provided
     * - If 'multiple-days-per-month', numTimesPerMonth must be provided
     */
    frequency_kind: FrequencyKind;
    /**
     * Days of the week (0-6, where 0=Monday, 6=Sunday)
     * Required when frequencyKind is 'specific-days-per-week'
     */
    days_of_week?: Array<number>;
    /**
     * Number of times per week
     * Required when frequencyKind is 'multiple-days-per-week'
     */
    num_times_per_week?: number;
    /**
     * Number of times per month
     * Required when frequencyKind is 'multiple-days-per-month'
     */
    num_times_per_month?: number;
    /**
     * Day of the month (1-31)
     * Required when frequencyKind is 'specific-day-of-month'
     */
    day_of_month?: number;
};

/**
 * Request body for creating a new note
 */
export type CreateNoteRequest = {
    /**
     * The note title
     */
    title: string;
    /**
     * The note content
     */
    content: string;
};

/**
 * Request body for creating a new todo
 */
export type CreateTodoRequest = {
    /**
     * The task description
     */
    task: string;
    /**
     * Additional details stored as JSON
     */
    details?: {
        [key: string]: unknown;
    };
    /**
     * Current status of the todo (defaults to 'todo')
     */
    status?: TodoStatus;
    /**
     * Where to insert the todo (defaults to top)
     */
    position?: TodoPosition;
    /**
     * Importance level (0-5)
     */
    importance?: Importance;
    /**
     * Estimated time to complete
     */
    time_estimate?: TimeEstimate;
    /**
     * Annoyingness level (0-4)
     */
    annoyingness?: Annoyingness;
    /**
     * Whether the todo is committed (defaults to false)
     */
    committed?: boolean;
    /**
     * Whether the todo is atomic (defaults to false)
     */
    atomic?: boolean;
    /**
     * Whether the todo is infinitely divisible (defaults to false)
     */
    infinitely_divisible?: boolean;
};

/**
 * Error response
 */
export type ErrorResponse = {
    /**
     * Error message
     */
    message: string;
    /**
     * Error code
     */
    code?: string;
};

/**
 * Frequency kind for recurring todos
 */
export type FrequencyKind = 'specific-days-per-week' | 'multiple-days-per-week' | 'specific-day-of-month' | 'multiple-days-per-month';

/**
 * A fun item
 */
export type Fun = {
    /**
     * Unique identifier for the fun
     */
    id: string;
    /**
     * The fun title
     */
    title: string;
    /**
     * ID of the user who owns this fun
     */
    user_id: string;
    /**
     * Order/position of the fun in the list
     */
    order: string;
    /**
     * When the fun was created
     */
    date_created: string;
    /**
     * When the fun was last updated
     */
    date_updated: string;
};

/**
 * A habit item
 */
export type Habit = {
    /**
     * Unique identifier for the habit
     */
    id: string;
    /**
     * The habit description
     */
    task: string;
    /**
     * Additional details stored as JSON
     */
    details?: {
        [key: string]: unknown;
    };
    /**
     * Current status of the habit
     */
    status: TodoStatus;
    /**
     * When the habit was created
     */
    date_created: string;
    /**
     * When the habit was last updated
     */
    date_updated: string;
    /**
     * ID of the user who owns this habit
     */
    user_id: string;
    /**
     * Order/position of the habit in the list
     */
    order: string;
    /**
     * Integer priority position (0-based index in the ordered list)
     */
    priority?: number;
    /**
     * Calculated desirability score for weighted random selection
     */
    desirability?: number;
    /**
     * Importance level (0-5)
     */
    importance?: Importance;
    /**
     * Estimated time to complete
     */
    time_estimate?: TimeEstimate;
    /**
     * Annoyingness level (0-4)
     */
    annoyingness: Annoyingness;
    /**
     * Whether the habit is committed
     */
    committed: boolean;
    /**
     * Elapsed time in seconds for timer
     */
    elapsedTimeSeconds: number;
    /**
     * Whether the habit is atomic (cannot be broken down)
     */
    atomic: boolean;
    /**
     * Whether the habit is infinitely divisible
     */
    infinitely_divisible: boolean;
    /**
     * Frequency kind for recurring habits
     * Constraints:
     * - If 'specific-days-per-week', daysOfWeek must be provided
     * - If 'multiple-days-per-week', numTimesPerWeek must be provided
     * - If 'specific-day-of-month', dayOfMonth must be provided
     * - If 'multiple-days-per-month', numTimesPerMonth must be provided
     */
    frequency_kind: FrequencyKind;
    /**
     * Days of the week (0-6, where 0=Monday, 6=Sunday)
     * Required when frequencyKind is 'specific-days-per-week'
     */
    days_of_week?: Array<number>;
    /**
     * Number of times per week
     * Required when frequencyKind is 'multiple-days-per-week'
     */
    num_times_per_week?: number;
    /**
     * Number of times per month
     * Required when frequencyKind is 'multiple-days-per-month'
     */
    num_times_per_month?: number;
    /**
     * Day of the month (1-31)
     * Required when frequencyKind is 'specific-day-of-month'
     */
    day_of_month?: number;
    /**
     * Days of the week when habit was completed this week (0-6, where 0=Monday, 6=Sunday)
     */
    done_this_week: Array<number>;
};

/**
 * Importance level (0-5)
 */
export type Importance = number;

/**
 * Request body for logging a habit completion
 */
export type LogHabitRequest = {
    /**
     * The date when the habit was completed (YYYY-MM-DD format)
     */
    when: string;
};

/**
 * A note item
 */
export type Note = {
    /**
     * Unique identifier for the note
     */
    id: string;
    /**
     * The note title
     */
    title: string;
    /**
     * The note content
     */
    content: string;
    /**
     * ID of the user who owns this note
     */
    user_id: string;
    /**
     * When the note was created
     */
    date_created: string;
    /**
     * When the note was last updated
     */
    date_updated: string;
};

/**
 * Request body for overriding elapsed time
 */
export type OverrideElapsedTimeRequest = {
    /**
     * Hours component of elapsed time
     */
    hours: number;
    /**
     * Minutes component of elapsed time
     */
    minutes: number;
};

/**
 * Insert after a specific todo
 */
export type PositionAfter = {
    type: 'after';
    /**
     * ID of the todo to insert after
     */
    id: string;
};

/**
 * Insert at the bottom of the list
 */
export type PositionBottom = {
    type: 'bottom';
};

/**
 * Insert at the top of the list
 */
export type PositionTop = {
    type: 'top';
};

/**
 * Request body for reordering a todo
 */
export type ReorderTodoRequest = {
    /**
     * New position for the todo
     */
    position: TodoPosition;
};

/**
 * Time estimate for completing a todo
 */
export type TimeEstimate = '1-min' | '5-mins' | '15-mins' | '30-mins' | '1-hour' | '2-hours' | 'half-day' | 'one-day' | 'project';

/**
 * A todo item
 */
export type Todo = {
    /**
     * Unique identifier for the todo
     */
    id: string;
    /**
     * The task description
     */
    task: string;
    /**
     * Additional details stored as JSON
     */
    details?: {
        [key: string]: unknown;
    };
    /**
     * Current status of the todo
     */
    status: TodoStatus;
    /**
     * When the todo was created
     */
    date_created: string;
    /**
     * When the todo was last updated
     */
    date_updated: string;
    /**
     * ID of the user who owns this todo
     */
    user_id: string;
    /**
     * Order/position of the todo in the list
     */
    order: string;
    /**
     * Integer priority position (0-based index in the ordered list)
     */
    priority?: number;
    /**
     * Calculated desirability score for weighted random selection
     */
    desirability?: number;
    /**
     * Importance level (0-5)
     */
    importance?: Importance;
    /**
     * Estimated time to complete
     */
    time_estimate?: TimeEstimate;
    /**
     * Annoyingness level (0-4)
     */
    annoyingness: Annoyingness;
    /**
     * Whether the todo is committed
     */
    committed: boolean;
    /**
     * Elapsed time in seconds for timer
     */
    elapsedTimeSeconds: number;
    /**
     * Whether the todo is atomic (cannot be broken down)
     */
    atomic: boolean;
    /**
     * Whether the todo is infinitely divisible
     */
    infinitely_divisible: boolean;
};

/**
 * Position for inserting a new todo
 */
export type TodoPosition = PositionTop | PositionBottom | PositionAfter;

/**
 * Status of a todo item
 */
export type TodoStatus = 'todo' | 'complete' | 'archived' | 'waiting';

/**
 * JWT token response
 */
export type Token = {
    /**
     * JWT access token
     */
    access_token: string;
    /**
     * Token type (always 'bearer')
     */
    token_type: string;
};

/**
 * Request body for updating a fun
 */
export type UpdateFunRequest = {
    /**
     * The fun title
     */
    title?: string;
};

/**
 * Request body for updating a habit
 */
export type UpdateHabitRequest = {
    /**
     * The habit description
     */
    task?: string;
    /**
     * Additional details stored as JSON
     */
    details?: {
        [key: string]: unknown;
    };
    /**
     * Current status of the habit
     */
    status?: TodoStatus;
    /**
     * Importance level (0-5)
     */
    importance?: Importance;
    /**
     * Estimated time to complete
     */
    time_estimate?: TimeEstimate;
    /**
     * Annoyingness level (0-4)
     */
    annoyingness?: Annoyingness;
    /**
     * Whether the habit is committed
     */
    committed?: boolean;
    /**
     * Whether the habit is atomic
     */
    atomic?: boolean;
    /**
     * Whether the habit is infinitely divisible
     */
    infinitely_divisible?: boolean;
    /**
     * Frequency kind for recurring habits
     * Constraints:
     * - If 'specific-days-per-week', daysOfWeek must be provided
     * - If 'multiple-days-per-week', numTimesPerWeek must be provided
     * - If 'specific-day-of-month', dayOfMonth must be provided
     * - If 'multiple-days-per-month', numTimesPerMonth must be provided
     */
    frequency_kind?: FrequencyKind;
    /**
     * Days of the week (0-6, where 0=Monday, 6=Sunday)
     * Required when frequencyKind is 'specific-days-per-week'
     */
    days_of_week?: Array<number>;
    /**
     * Number of times per week
     * Required when frequencyKind is 'multiple-days-per-week'
     */
    num_times_per_week?: number;
    /**
     * Number of times per month
     * Required when frequencyKind is 'multiple-days-per-month'
     */
    num_times_per_month?: number;
    /**
     * Day of the month (1-31)
     * Required when frequencyKind is 'specific-day-of-month'
     */
    day_of_month?: number;
};

/**
 * Request body for updating a note
 */
export type UpdateNoteRequest = {
    /**
     * The note title
     */
    title?: string;
    /**
     * The note content
     */
    content?: string;
};

/**
 * Request body for updating a todo
 */
export type UpdateTodoRequest = {
    /**
     * The task description
     */
    task?: string;
    /**
     * Additional details stored as JSON
     */
    details?: {
        [key: string]: unknown;
    };
    /**
     * Current status of the todo
     */
    status?: TodoStatus;
    /**
     * Importance level (0-5)
     */
    importance?: Importance;
    /**
     * Estimated time to complete
     */
    time_estimate?: TimeEstimate;
    /**
     * Annoyingness level (0-4)
     */
    annoyingness?: Annoyingness;
    /**
     * Whether the todo is committed
     */
    committed?: boolean;
    /**
     * Whether the todo is atomic
     */
    atomic?: boolean;
    /**
     * Whether the todo is infinitely divisible
     */
    infinitely_divisible?: boolean;
};

/**
 * User model
 */
export type User = {
    /**
     * Unique identifier for the user
     */
    id: string;
    /**
     * User's email address
     */
    email: string;
    /**
     * Whether the user account is active
     */
    is_active: boolean;
    /**
     * When the user was created
     */
    date_created: string;
    /**
     * When the user was last updated
     */
    date_updated: string;
};

/**
 * Request body for user login
 */
export type UserLoginRequest = {
    /**
     * User's email address
     */
    email: string;
    /**
     * User's password
     */
    password: string;
};

/**
 * Request body for user registration
 */
export type UserRegisterRequest = {
    /**
     * User's email address
     */
    email: string;
    /**
     * User's password
     */
    password: string;
};

export type AuthLoginData = {
    body: UserLoginRequest;
    path?: never;
    query?: never;
    url: '/api/auth/login';
};

export type AuthLoginErrors = {
    /**
     * Access is unauthorized.
     */
    401: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type AuthLoginError = AuthLoginErrors[keyof AuthLoginErrors];

export type AuthLoginResponses = {
    /**
     * The request has succeeded.
     */
    200: Token;
};

export type AuthLoginResponse = AuthLoginResponses[keyof AuthLoginResponses];

export type AuthLogoutData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/logout';
};

export type AuthLogoutErrors = {
    /**
     * Access is unauthorized.
     */
    401: ErrorResponse;
};

export type AuthLogoutError = AuthLogoutErrors[keyof AuthLogoutErrors];

export type AuthLogoutResponses = {
    /**
     * The request has succeeded.
     */
    200: unknown;
};

export type AuthGetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/me';
};

export type AuthGetCurrentUserErrors = {
    /**
     * Access is unauthorized.
     */
    401: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type AuthGetCurrentUserError = AuthGetCurrentUserErrors[keyof AuthGetCurrentUserErrors];

export type AuthGetCurrentUserResponses = {
    /**
     * The request has succeeded.
     */
    200: User;
};

export type AuthGetCurrentUserResponse = AuthGetCurrentUserResponses[keyof AuthGetCurrentUserResponses];

export type AuthRefreshTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/refresh';
};

export type AuthRefreshTokenErrors = {
    /**
     * Access is unauthorized.
     */
    401: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type AuthRefreshTokenError = AuthRefreshTokenErrors[keyof AuthRefreshTokenErrors];

export type AuthRefreshTokenResponses = {
    /**
     * The request has succeeded.
     */
    200: Token;
};

export type AuthRefreshTokenResponse = AuthRefreshTokenResponses[keyof AuthRefreshTokenResponses];

export type AuthRegisterData = {
    body: UserRegisterRequest;
    path?: never;
    query?: never;
    url: '/api/auth/register';
};

export type AuthRegisterErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type AuthRegisterError = AuthRegisterErrors[keyof AuthRegisterErrors];

export type AuthRegisterResponses = {
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: User;
};

export type AuthRegisterResponse = AuthRegisterResponses[keyof AuthRegisterResponses];

export type FunsListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/funs';
};

export type FunsListErrors = {
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type FunsListError = FunsListErrors[keyof FunsListErrors];

export type FunsListResponses = {
    /**
     * The request has succeeded.
     */
    200: Array<Fun>;
};

export type FunsListResponse = FunsListResponses[keyof FunsListResponses];

export type FunsCreateData = {
    body: CreateFunRequest;
    path?: never;
    query?: never;
    url: '/api/funs';
};

export type FunsCreateErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type FunsCreateError = FunsCreateErrors[keyof FunsCreateErrors];

export type FunsCreateResponses = {
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: Fun;
};

export type FunsCreateResponse = FunsCreateResponses[keyof FunsCreateResponses];

export type FunsDeleteData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/funs/{id}';
};

export type FunsDeleteErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type FunsDeleteError = FunsDeleteErrors[keyof FunsDeleteErrors];

export type FunsDeleteResponses = {
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type FunsDeleteResponse = FunsDeleteResponses[keyof FunsDeleteResponses];

export type FunsGetData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/funs/{id}';
};

export type FunsGetErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type FunsGetError = FunsGetErrors[keyof FunsGetErrors];

export type FunsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: Fun;
};

export type FunsGetResponse = FunsGetResponses[keyof FunsGetResponses];

export type FunsUpdateData = {
    body: UpdateFunRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/funs/{id}';
};

export type FunsUpdateErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type FunsUpdateError = FunsUpdateErrors[keyof FunsUpdateErrors];

export type FunsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: Fun;
};

export type FunsUpdateResponse = FunsUpdateResponses[keyof FunsUpdateResponses];

export type FunsReorderData = {
    body: ReorderTodoRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/funs/{id}/reorder';
};

export type FunsReorderErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type FunsReorderError = FunsReorderErrors[keyof FunsReorderErrors];

export type FunsReorderResponses = {
    /**
     * The request has succeeded.
     */
    200: Fun;
};

export type FunsReorderResponse = FunsReorderResponses[keyof FunsReorderResponses];

export type HabitsListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/habits';
};

export type HabitsListErrors = {
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type HabitsListError = HabitsListErrors[keyof HabitsListErrors];

export type HabitsListResponses = {
    /**
     * The request has succeeded.
     */
    200: Array<Habit>;
};

export type HabitsListResponse = HabitsListResponses[keyof HabitsListResponses];

export type HabitsCreateData = {
    body: CreateHabitRequest;
    path?: never;
    query?: never;
    url: '/api/habits';
};

export type HabitsCreateErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type HabitsCreateError = HabitsCreateErrors[keyof HabitsCreateErrors];

export type HabitsCreateResponses = {
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: Habit;
};

export type HabitsCreateResponse = HabitsCreateResponses[keyof HabitsCreateResponses];

export type HabitsDeleteData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/habits/{id}';
};

export type HabitsDeleteErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type HabitsDeleteError = HabitsDeleteErrors[keyof HabitsDeleteErrors];

export type HabitsDeleteResponses = {
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type HabitsDeleteResponse = HabitsDeleteResponses[keyof HabitsDeleteResponses];

export type HabitsGetData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/habits/{id}';
};

export type HabitsGetErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type HabitsGetError = HabitsGetErrors[keyof HabitsGetErrors];

export type HabitsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: Habit;
};

export type HabitsGetResponse = HabitsGetResponses[keyof HabitsGetResponses];

export type HabitsUpdateData = {
    body: UpdateHabitRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/habits/{id}';
};

export type HabitsUpdateErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type HabitsUpdateError = HabitsUpdateErrors[keyof HabitsUpdateErrors];

export type HabitsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: Habit;
};

export type HabitsUpdateResponse = HabitsUpdateResponses[keyof HabitsUpdateResponses];

export type HabitsLogHabitData = {
    body: LogHabitRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/habits/{id}/log';
};

export type HabitsLogHabitErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type HabitsLogHabitError = HabitsLogHabitErrors[keyof HabitsLogHabitErrors];

export type HabitsLogHabitResponses = {
    /**
     * The request has succeeded.
     */
    200: unknown;
};

export type HabitsDeleteHabitLogData = {
    body?: never;
    path: {
        id: string;
        date: string;
    };
    query?: never;
    url: '/api/habits/{id}/log/{date}';
};

export type HabitsDeleteHabitLogErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type HabitsDeleteHabitLogError = HabitsDeleteHabitLogErrors[keyof HabitsDeleteHabitLogErrors];

export type HabitsDeleteHabitLogResponses = {
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type HabitsDeleteHabitLogResponse = HabitsDeleteHabitLogResponses[keyof HabitsDeleteHabitLogResponses];

export type NoteApiListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/note';
};

export type NoteApiListErrors = {
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type NoteApiListError = NoteApiListErrors[keyof NoteApiListErrors];

export type NoteApiListResponses = {
    /**
     * The request has succeeded.
     */
    200: Array<Note>;
};

export type NoteApiListResponse = NoteApiListResponses[keyof NoteApiListResponses];

export type NoteApiCreateData = {
    body: CreateNoteRequest;
    path?: never;
    query?: never;
    url: '/api/note';
};

export type NoteApiCreateErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type NoteApiCreateError = NoteApiCreateErrors[keyof NoteApiCreateErrors];

export type NoteApiCreateResponses = {
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: Note;
};

export type NoteApiCreateResponse = NoteApiCreateResponses[keyof NoteApiCreateResponses];

export type NoteApiDeleteData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/note/{id}';
};

export type NoteApiDeleteErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type NoteApiDeleteError = NoteApiDeleteErrors[keyof NoteApiDeleteErrors];

export type NoteApiDeleteResponses = {
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NoteApiDeleteResponse = NoteApiDeleteResponses[keyof NoteApiDeleteResponses];

export type NoteApiGetData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/note/{id}';
};

export type NoteApiGetErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type NoteApiGetError = NoteApiGetErrors[keyof NoteApiGetErrors];

export type NoteApiGetResponses = {
    /**
     * The request has succeeded.
     */
    200: Note;
};

export type NoteApiGetResponse = NoteApiGetResponses[keyof NoteApiGetResponses];

export type NoteApiUpdateData = {
    body: UpdateNoteRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/note/{id}';
};

export type NoteApiUpdateErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type NoteApiUpdateError = NoteApiUpdateErrors[keyof NoteApiUpdateErrors];

export type NoteApiUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: Note;
};

export type NoteApiUpdateResponse = NoteApiUpdateResponses[keyof NoteApiUpdateResponses];

export type TodosListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/todos';
};

export type TodosListErrors = {
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosListError = TodosListErrors[keyof TodosListErrors];

export type TodosListResponses = {
    /**
     * The request has succeeded.
     */
    200: Array<Todo>;
};

export type TodosListResponse = TodosListResponses[keyof TodosListResponses];

export type TodosCreateData = {
    body: CreateTodoRequest;
    path?: never;
    query?: never;
    url: '/api/todos';
};

export type TodosCreateErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosCreateError = TodosCreateErrors[keyof TodosCreateErrors];

export type TodosCreateResponses = {
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: Todo;
};

export type TodosCreateResponse = TodosCreateResponses[keyof TodosCreateResponses];

export type TodosGenerateBreakUpTodosData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/todos/generate-break-up-todos';
};

export type TodosGenerateBreakUpTodosErrors = {
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosGenerateBreakUpTodosError = TodosGenerateBreakUpTodosErrors[keyof TodosGenerateBreakUpTodosErrors];

export type TodosGenerateBreakUpTodosResponses = {
    /**
     * The request has succeeded.
     */
    200: Array<Todo>;
};

export type TodosGenerateBreakUpTodosResponse = TodosGenerateBreakUpTodosResponses[keyof TodosGenerateBreakUpTodosResponses];

export type TodosDeleteData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/todos/{id}';
};

export type TodosDeleteErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosDeleteError = TodosDeleteErrors[keyof TodosDeleteErrors];

export type TodosDeleteResponses = {
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type TodosDeleteResponse = TodosDeleteResponses[keyof TodosDeleteResponses];

export type TodosGetData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/todos/{id}';
};

export type TodosGetErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosGetError = TodosGetErrors[keyof TodosGetErrors];

export type TodosGetResponses = {
    /**
     * The request has succeeded.
     */
    200: Todo;
};

export type TodosGetResponse = TodosGetResponses[keyof TodosGetResponses];

export type TodosUpdateData = {
    body: UpdateTodoRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/todos/{id}';
};

export type TodosUpdateErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosUpdateError = TodosUpdateErrors[keyof TodosUpdateErrors];

export type TodosUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: Todo;
};

export type TodosUpdateResponse = TodosUpdateResponses[keyof TodosUpdateResponses];

export type TodosReorderData = {
    body: ReorderTodoRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/todos/{id}/reorder';
};

export type TodosReorderErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosReorderError = TodosReorderErrors[keyof TodosReorderErrors];

export type TodosReorderResponses = {
    /**
     * The request has succeeded.
     */
    200: Todo;
};

export type TodosReorderResponse = TodosReorderResponses[keyof TodosReorderResponses];

export type TodosStartTimerData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/todos/{id}/start-timer';
};

export type TodosStartTimerErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosStartTimerError = TodosStartTimerErrors[keyof TodosStartTimerErrors];

export type TodosStartTimerResponses = {
    /**
     * The request has succeeded.
     */
    200: unknown;
};

export type TodosStopTimerData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/todos/{id}/stop-timer';
};

export type TodosStopTimerErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosStopTimerError = TodosStopTimerErrors[keyof TodosStopTimerErrors];

export type TodosStopTimerResponses = {
    /**
     * The request has succeeded.
     */
    200: unknown;
};

export type TodosOverrideElapsedTimeData = {
    body: OverrideElapsedTimeRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/todos/{id}/time-elapsed-override';
};

export type TodosOverrideElapsedTimeErrors = {
    /**
     * The server cannot find the requested resource.
     */
    404: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type TodosOverrideElapsedTimeError = TodosOverrideElapsedTimeErrors[keyof TodosOverrideElapsedTimeErrors];

export type TodosOverrideElapsedTimeResponses = {
    /**
     * The request has succeeded.
     */
    200: unknown;
};

export type WeightedRandomFunsListData = {
    body?: never;
    path?: never;
    query: {
        n: number;
        excludeIds?: Array<string>;
    };
    url: '/api/weighted-random-funs';
};

export type WeightedRandomFunsListErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type WeightedRandomFunsListError = WeightedRandomFunsListErrors[keyof WeightedRandomFunsListErrors];

export type WeightedRandomFunsListResponses = {
    /**
     * The request has succeeded.
     */
    200: Array<Fun>;
};

export type WeightedRandomFunsListResponse = WeightedRandomFunsListResponses[keyof WeightedRandomFunsListResponses];

export type WeightedRandomTodosListData = {
    body?: never;
    path?: never;
    query: {
        n: number;
        maxTimeEstimate?: TimeEstimate;
    };
    url: '/api/weighted-random-todos';
};

export type WeightedRandomTodosListErrors = {
    /**
     * The server could not understand the request due to invalid syntax.
     */
    400: ErrorResponse;
    /**
     * Server error
     */
    500: ErrorResponse;
};

export type WeightedRandomTodosListError = WeightedRandomTodosListErrors[keyof WeightedRandomTodosListErrors];

export type WeightedRandomTodosListResponses = {
    /**
     * The request has succeeded.
     */
    200: Array<Todo>;
};

export type WeightedRandomTodosListResponse = WeightedRandomTodosListResponses[keyof WeightedRandomTodosListResponses];
