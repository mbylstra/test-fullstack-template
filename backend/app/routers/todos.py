# FastAPI router for Todo endpoints
# Generated from OpenAPI specification

from typing import List
from pydantic import BaseModel, Field
import uuid
import time
from fastapi import APIRouter, HTTPException, status, Depends
from sqlalchemy.orm import Session
from app.auth import get_current_user
from app.autogenerated.pydantic_models import (
    Todo as TodoResponse,
    CreateTodoRequest,
    UpdateTodoRequest,
    ReorderTodoRequest,
    ErrorResponse,
    TodoStatus as PydanticTodoStatus,
    TimeEstimate as PydanticTimeEstimate,
    Importance,
    Annoyingness,
)
from app.models.todo import Todo as TodoModel, TodoStatus, TimeEstimate, TimerStartEvent, TimerStopEvent, TimeElapsedOverrideEvent, generate_break_up_todos
from app.models.desirability import calculate_desirabilities
from app.models.user import User as UserModel
from app.database import get_db

router = APIRouter(prefix="/api/todos", tags=["Todos"])


class SetElapsedTimeRequest(BaseModel):
    hours: int = Field(..., ge=0, description="Hours of elapsed time")
    minutes: int = Field(..., ge=0, lt=60, description="Minutes of elapsed time")


@router.get(
    "",
    response_model=List[TodoResponse],
    status_code=status.HTTP_200_OK,
    responses={
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="List all todos for the authenticated user",
)
async def list_todos(
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> List[TodoResponse]:
    """
    List all todos for the authenticated user.

    Returns:
        List[Todo]: List of all todos
    """
    todos = db.query(TodoModel).filter(TodoModel.user_id == current_user.id).order_by(TodoModel.order).all()

    # Calculate desirability for all todos
    todo_desirabilities = calculate_desirabilities(todos)

    return [
        TodoResponse(
            id=todo.id,
            task=todo.task,
            details=todo.details,
            status=PydanticTodoStatus(todo.status.value),
            date_created=todo.date_created,
            date_updated=todo.date_updated,
            user_id=todo.user_id,
            order=todo.order,
            priority=i,
            desirability=todo_desirabilities.get(todo.id),
            importance=Importance(todo.importance),
            time_estimate=PydanticTimeEstimate(todo.time_estimate.value) if todo.time_estimate else None,
            annoyingness=Annoyingness(todo.annoyingness),
            committed=todo.committed,
            elapsedTimeSeconds=int(todo.time_elapsed()),
            atomic=todo.atomic,
            infinitely_divisible=todo.infinitely_divisible,
        )
        for i, todo in enumerate(todos)
    ]


@router.post(
    "",
    response_model=TodoResponse,
    status_code=status.HTTP_201_CREATED,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Create a new todo",
)
async def create_todo(
    todo: CreateTodoRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> TodoResponse:
    """
    Create a new todo.

    Args:
        todo: The todo data to create

    Returns:
        Todo: The created todo
    """
    from fractional_indexing import generate_key_between
    from app.autogenerated.pydantic_models import PositionTop, PositionBottom, PositionAfter

    # Generate a new UUID for the todo
    todo_id = str(uuid.uuid4())

    # Get ALL todos (including archived) sorted by order to avoid conflicts
    all_todos = db.query(TodoModel).filter(
        TodoModel.user_id == current_user.id
    ).order_by(TodoModel.order).all()

    # Calculate order based on position
    if todo.position:
        position_value = todo.position.root
        if isinstance(position_value, PositionTop):
            # Insert at the top
            first_order = all_todos[0].order if all_todos else None
            new_order = generate_key_between(None, first_order)
        elif isinstance(position_value, PositionBottom):
            # Insert at the bottom
            last_order = all_todos[-1].order if all_todos else None
            new_order = generate_key_between(last_order, None)
        elif isinstance(position_value, PositionAfter):
            # Insert after a specific todo
            after_index = next((i for i, t in enumerate(all_todos) if t.id == position_value.id), None)
            if after_index is None:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Todo with id {position_value.id} not found"
                )
            after_todo = all_todos[after_index]
            next_todo = all_todos[after_index + 1] if after_index + 1 < len(all_todos) else None
            new_order = generate_key_between(after_todo.order, next_todo.order if next_todo else None)
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid position type"
            )
    else:
        # Default to top
        first_order = all_todos[0].order if all_todos else None
        new_order = generate_key_between(None, first_order)

    # Convert Pydantic enums to SQLAlchemy enums
    db_status = TodoStatus(todo.status.value) if todo.status else TodoStatus.TODO
    db_time_estimate = TimeEstimate(todo.time_estimate.value) if todo.time_estimate else None

    # Create new todo
    db_todo = TodoModel(
        id=todo_id,
        task=todo.task,
        details=todo.details,
        status=db_status,
        user_id=current_user.id,
        order=new_order,
        importance=todo.importance.root if todo.importance else None,
        time_estimate=db_time_estimate,
        annoyingness=todo.annoyingness.root if todo.annoyingness else 0,
        committed=todo.committed or False,
    )

    db.add(db_todo)
    db.commit()
    db.refresh(db_todo)

    # Get all todos to calculate priority and desirability
    all_todos = db.query(TodoModel).filter(TodoModel.user_id == current_user.id).order_by(TodoModel.order).all()
    todo_desirabilities = calculate_desirabilities(all_todos)

    # Find the priority (index) of the newly created todo
    priority = next((i for i, t in enumerate(all_todos) if t.id == db_todo.id), None)

    return TodoResponse(
        id=db_todo.id,
        task=db_todo.task,
        details=db_todo.details,
        status=PydanticTodoStatus(db_todo.status.value),
        date_created=db_todo.date_created,
        date_updated=db_todo.date_updated,
        user_id=db_todo.user_id,
        order=db_todo.order,
        priority=priority,
        desirability=todo_desirabilities.get(db_todo.id),
        importance=Importance(db_todo.importance),
        time_estimate=PydanticTimeEstimate(db_todo.time_estimate.value) if db_todo.time_estimate else None,
        annoyingness=Annoyingness(db_todo.annoyingness),
        committed=db_todo.committed,
        elapsedTimeSeconds=int(db_todo.time_elapsed()),
        atomic=db_todo.atomic,
        infinitely_divisible=db_todo.infinitely_divisible,
    )


@router.get(
    "/{id}",
    response_model=TodoResponse,
    status_code=status.HTTP_200_OK,
    responses={
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Get a specific todo by ID",
)
async def get_todo(
    id: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> TodoResponse:
    """
    Get a specific todo by ID.

    Args:
        id: The todo ID

    Returns:
        Todo: The requested todo

    Raises:
        HTTPException: 404 if todo not found
    """
    db_todo = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id
    ).first()

    if not db_todo:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {id} not found"
        )

    # Get all todos to calculate priority and desirability
    all_todos = db.query(TodoModel).filter(TodoModel.user_id == current_user.id).order_by(TodoModel.order).all()
    todo_desirabilities = calculate_desirabilities(all_todos)

    # Find the priority (index) of the requested todo
    priority = next((i for i, t in enumerate(all_todos) if t.id == db_todo.id), None)

    return TodoResponse(
        id=db_todo.id,
        task=db_todo.task,
        details=db_todo.details,
        status=PydanticTodoStatus(db_todo.status.value),
        date_created=db_todo.date_created,
        date_updated=db_todo.date_updated,
        user_id=db_todo.user_id,
        order=db_todo.order,
        priority=priority,
        desirability=todo_desirabilities.get(db_todo.id),
        importance=Importance(db_todo.importance),
        time_estimate=PydanticTimeEstimate(db_todo.time_estimate.value) if db_todo.time_estimate else None,
        annoyingness=Annoyingness(db_todo.annoyingness),
        committed=db_todo.committed,
        elapsedTimeSeconds=int(db_todo.time_elapsed()),
        atomic=db_todo.atomic,
        infinitely_divisible=db_todo.infinitely_divisible,
    )


@router.patch(
    "/{id}",
    response_model=TodoResponse,
    status_code=status.HTTP_200_OK,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Update a todo",
)
async def update_todo(
    id: str,
    todo: UpdateTodoRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> TodoResponse:
    """
    Update a todo.

    Args:
        id: The todo ID
        todo: The updated todo data

    Returns:
        Todo: The updated todo

    Raises:
        HTTPException: 404 if todo not found
    """
    db_todo = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id
    ).first()

    if not db_todo:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {id} not found"
        )

    # Update only provided fields
    if todo.task is not None:
        db_todo.task = todo.task
    if todo.details is not None:
        db_todo.details = todo.details
    if todo.status is not None:
        db_todo.status = TodoStatus(todo.status.value)
    if todo.importance is not None:
        db_todo.importance = todo.importance.root
    if todo.time_estimate is not None:
        db_todo.time_estimate = TimeEstimate(todo.time_estimate.value)
    if todo.annoyingness is not None:
        db_todo.annoyingness = todo.annoyingness.root
    if todo.committed is not None:
        db_todo.committed = todo.committed
    if todo.atomic is not None:
        db_todo.atomic = todo.atomic
    if todo.infinitely_divisible is not None:
        db_todo.infinitely_divisible = todo.infinitely_divisible

    db.commit()
    db.refresh(db_todo)

    # Get all todos to calculate priority and desirability
    all_todos = db.query(TodoModel).filter(TodoModel.user_id == current_user.id).order_by(TodoModel.order).all()
    todo_desirabilities = calculate_desirabilities(all_todos)

    # Find the priority (index) of the updated todo
    priority = next((i for i, t in enumerate(all_todos) if t.id == db_todo.id), None)

    return TodoResponse(
        id=db_todo.id,
        task=db_todo.task,
        details=db_todo.details,
        status=PydanticTodoStatus(db_todo.status.value),
        date_created=db_todo.date_created,
        date_updated=db_todo.date_updated,
        user_id=db_todo.user_id,
        order=db_todo.order,
        priority=priority,
        desirability=todo_desirabilities.get(db_todo.id),
        importance=Importance(db_todo.importance),
        time_estimate=PydanticTimeEstimate(db_todo.time_estimate.value) if db_todo.time_estimate else None,
        annoyingness=Annoyingness(db_todo.annoyingness),
        committed=db_todo.committed,
        elapsedTimeSeconds=int(db_todo.time_elapsed()),
        atomic=db_todo.atomic,
        infinitely_divisible=db_todo.infinitely_divisible,
    )


@router.delete(
    "/{id}",
    status_code=status.HTTP_204_NO_CONTENT,
    responses={
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Delete a todo",
)
async def delete_todo(
    id: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> None:
    """
    Delete a todo.

    Args:
        id: The todo ID

    Raises:
        HTTPException: 404 if todo not found
    """
    db_todo = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id
    ).first()

    if not db_todo:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {id} not found"
        )

    db.delete(db_todo)
    db.commit()


@router.post(
    "/{id}/reorder",
    response_model=TodoResponse,
    status_code=status.HTTP_200_OK,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Reorder a todo",
)
async def reorder_todo(
    id: str,
    request: ReorderTodoRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> TodoResponse:
    """
    Reorder a todo.

    Args:
        id: The todo ID
        request: The reorder request with position

    Returns:
        Todo: The reordered todo

    Raises:
        HTTPException: 404 if todo not found
    """
    from fractional_indexing import generate_key_between
    from app.autogenerated.pydantic_models import PositionTop, PositionBottom, PositionAfter

    # Find the todo to reorder
    db_todo = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id
    ).first()

    if not db_todo:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {id} not found"
        )

    # Get ALL todos (including archived) sorted by order to avoid conflicts
    all_todos = db.query(TodoModel).filter(
        TodoModel.user_id == current_user.id
    ).order_by(TodoModel.order).all()

    # Calculate new order based on position
    position_value = request.position.root
    if isinstance(position_value, PositionTop):
        # Move to the top
        first_order = all_todos[0].order if all_todos else None
        new_order = generate_key_between(None, first_order)
    elif isinstance(position_value, PositionBottom):
        # Move to the bottom
        last_order = all_todos[-1].order if all_todos else None
        new_order = generate_key_between(last_order, None)
    elif isinstance(position_value, PositionAfter):
        # Move after a specific todo
        after_index = next((i for i, t in enumerate(all_todos) if t.id == position_value.id), None)
        if after_index is None:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Todo with id {position_value.id} not found"
            )
        after_todo = all_todos[after_index]
        next_todo = all_todos[after_index + 1] if after_index + 1 < len(all_todos) else None
        new_order = generate_key_between(after_todo.order, next_todo.order if next_todo else None)
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid position type"
        )

    # Update the order
    db_todo.order = new_order
    db.commit()
    db.refresh(db_todo)

    # Get all todos to calculate priority and desirability
    all_todos = db.query(TodoModel).filter(TodoModel.user_id == current_user.id).order_by(TodoModel.order).all()
    todo_desirabilities = calculate_desirabilities(all_todos)

    # Find the priority (index) of the reordered todo
    priority = next((i for i, t in enumerate(all_todos) if t.id == db_todo.id), None)

    return TodoResponse(
        id=db_todo.id,
        task=db_todo.task,
        details=db_todo.details,
        status=PydanticTodoStatus(db_todo.status.value),
        date_created=db_todo.date_created,
        date_updated=db_todo.date_updated,
        user_id=db_todo.user_id,
        order=db_todo.order,
        priority=priority,
        desirability=todo_desirabilities.get(db_todo.id),
        importance=Importance(db_todo.importance),
        time_estimate=PydanticTimeEstimate(db_todo.time_estimate.value) if db_todo.time_estimate else None,
        annoyingness=Annoyingness(db_todo.annoyingness),
        committed=db_todo.committed,
        elapsedTimeSeconds=int(db_todo.time_elapsed()),
        atomic=db_todo.atomic,
        infinitely_divisible=db_todo.infinitely_divisible,
    )


@router.post(
    "/{id}/start-timer",
    status_code=status.HTTP_200_OK,
    responses={
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Start a timer for a todo",
)
async def start_timer(
    id: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
) -> None:
    """
    Start a timer for a todo.

    Args:
        id: The todo ID

    Raises:
        HTTPException: 404 if todo not found
    """
    db_todo = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id
    ).first()

    if not db_todo:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {id} not found"
        )

    # Add timer start event
    timer_event: TimerStartEvent = {
        "event": "timer_start",
        "timestamp": time.time()
    }
    # Create new list to trigger SQLAlchemy change detection for JSONB field
    db_todo.timer_log = db_todo.timer_log + [timer_event]

    db.commit()


@router.post(
    "/{id}/stop-timer",
    status_code=status.HTTP_200_OK,
    responses={
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Stop a timer for a todo",
)
async def stop_timer(
    id: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
) -> None:
    """
    Stop a timer for a todo.

    Args:
        id: The todo ID

    Raises:
        HTTPException: 404 if todo not found
    """
    db_todo = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id
    ).first()

    if not db_todo:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {id} not found"
        )

    # Add timer stop event
    timer_event: TimerStopEvent = {
        "event": "timer_stop",
        "timestamp": time.time()
    }
    # Create new list to trigger SQLAlchemy change detection for JSONB field
    db_todo.timer_log = db_todo.timer_log + [timer_event]

    db.commit()


@router.post(
    "/{id}/time-elapsed-override",
    status_code=status.HTTP_200_OK,
    responses={
        404: {"model": ErrorResponse, "description": "Todo not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Set elapsed time override for a todo",
)
async def set_elapsed_time(
    id: str,
    request: SetElapsedTimeRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
) -> None:
    """
    Set an elapsed time override for a todo.

    This discards all previous timer events and sets the elapsed time
    to the specified hours and minutes. Subsequent timer start/stop events
    will add to this base time.

    Args:
        id: The todo ID
        request: Hours and minutes to set

    Raises:
        HTTPException: 404 if todo not found
    """
    db_todo = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id
    ).first()

    if not db_todo:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Todo with id {id} not found"
        )

    # Add time elapsed override event
    timer_event: TimeElapsedOverrideEvent = {
        "event": "time_elapsed_override",
        "timestamp": time.time(),
        "hours": request.hours,
        "minutes": request.minutes
    }
    # Create new list to trigger SQLAlchemy change detection for JSONB field
    db_todo.timer_log = db_todo.timer_log + [timer_event]

    db.commit()


@router.post(
    "/generate-break-up-todos",
    response_model=List[TodoResponse],
    status_code=status.HTTP_200_OK,
    responses={
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Generate break-up todos across all todos",
)
async def generate_break_up_todos_endpoint(
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> List[TodoResponse]:
    """
    Generate break-up todos for all tasks that meet the criteria.

    Creates a meta "break-up" todo for any task that:
    - Has a time estimate greater than 30 minutes
    - Is not already a parent (has no children)
    - Does not have a parent (parent_id is null)
    - Is not complete, waiting, or committed

    Returns:
        List[Todo]: Full list of all todos including newly created break-up todos
    """
    # Generate break-up todos
    break_up_todos = generate_break_up_todos(db, current_user.id)

    # Add them to the database
    for break_up_todo in break_up_todos:
        db.add(break_up_todo)

    db.commit()

    # Fetch all todos to return the full updated list
    all_todos = db.query(TodoModel).filter(
        TodoModel.user_id == current_user.id
    ).order_by(TodoModel.order).all()

    # Calculate desirability for all todos
    todo_desirabilities = calculate_desirabilities(all_todos)

    return [
        TodoResponse(
            id=todo.id,
            task=todo.task,
            details=todo.details,
            status=PydanticTodoStatus(todo.status.value),
            date_created=todo.date_created,
            date_updated=todo.date_updated,
            user_id=todo.user_id,
            order=todo.order,
            priority=i,
            desirability=todo_desirabilities.get(todo.id),
            importance=Importance(todo.importance),
            time_estimate=PydanticTimeEstimate(todo.time_estimate.value) if todo.time_estimate else None,
            annoyingness=Annoyingness(todo.annoyingness),
            committed=todo.committed,
            elapsedTimeSeconds=int(todo.time_elapsed()),
            atomic=todo.atomic,
            infinitely_divisible=todo.infinitely_divisible,
        )
        for i, todo in enumerate(all_todos)
    ]
