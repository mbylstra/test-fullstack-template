# FastAPI router for weighted random todos endpoint
import random
from typing import List, Optional
from fastapi import APIRouter, HTTPException, status, Depends, Query
from sqlalchemy.orm import Session
from app.auth import get_current_user
from app.autogenerated.pydantic_models import (
    Todo as TodoResponse,
    ErrorResponse,
    TodoStatus as PydanticTodoStatus,
    TimeEstimate as PydanticTimeEstimate,
    Importance,
    Annoyingness,
)
from app.models.todo import (
    Todo as TodoModel,
    TimeEstimate,
    get_chooseable_todos_filter,
    get_max_time_estimate_filter,
    annotate_integer_order,
)
from app.models.desirability import calculate_desirabilities
from app.models.user import User as UserModel
from app.database import get_db

router = APIRouter(prefix="/api/weighted-random-todos", tags=["Todos"])


@router.get(
    "",
    response_model=List[TodoResponse],
    status_code=status.HTTP_200_OK,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Get weighted random todos for the authenticated user",
)
async def list_weighted_random_todos(
    n: int,
    max_time_estimate: Optional[TimeEstimate] = Query(None, alias="maxTimeEstimate"),
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
) -> List[TodoResponse]:
    """
    Get weighted random todos for the authenticated user.

    Uses weighted random selection based on importance, annoyingness, time_estimate, and order.
    Each todo is assigned a weight using the formula:
    ((1 + normalized_importance) * IMPORTANCE_MULTIPLIER) +
    ((1 + normalized_annoyingness) * ANNOYINGNESS_MULTIPLIER) +
    ((1 + normalized_time_estimate) * TIME_ESTIMATE_MULTIPLIER) +
    ((1 + normalized_order) * ORDER_MULTIPLIER)

    Args:
        n: Number of todos to return
        max_time_estimate: Maximum time estimate to consider. Defaults to PROJECT if not specified.
            Todos with time estimates longer than this will have a normalized value of 0.

    Returns:
        List[Todo]: List of weighted random todos

    Raises:
        HTTPException: 400 if n is invalid
        HTTPException: 500 if server error occurs
    """
    try:
        if n < 1:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Parameter 'n' must be at least 1",
            )

        # Get all chooseable todos for the user with required fields
        query = (
            db.query(TodoModel)
            .filter(TodoModel.user_id == current_user.id)
            .filter(get_chooseable_todos_filter())
            .filter(TodoModel.time_estimate.isnot(None))
        )

        # Filter by max_time_estimate if specified
        if max_time_estimate is not None:
            query = query.filter(get_max_time_estimate_filter(max_time_estimate))

        todos_to_choose_from = query.order_by(TodoModel.order).all()

        # If there are no chooseable todos, return empty list
        if not todos_to_choose_from:
            return []

        # Calculate priority (integer order) and desirability for all chooseable todos
        annotated_orders = annotate_integer_order(todos_to_choose_from)
        max_time_est = max_time_estimate if max_time_estimate is not None else TimeEstimate.PROJECT

        # Calculate desirability scores for each todo
        todo_desirability = calculate_desirabilities(todos_to_choose_from, max_time_est)
        weights: list[float] = [
            todo_desirability[todo.id] or 0.0 for todo in todos_to_choose_from
        ]

        # Select todos without replacement (no duplicates)
        if n >= len(todos_to_choose_from):
            selected_todos = todos_to_choose_from
        else:
            # Perform weighted random selection without replacement
            selected_todos = []
            remaining_todos = list(todos_to_choose_from)
            remaining_weights = list(weights)

            for _ in range(n):
                # Select one todo using weighted random
                selected = random.choices(remaining_todos, weights=remaining_weights, k=1)[0]
                selected_todos.append(selected)

                # Remove the selected todo and its weight to prevent duplicates
                index = remaining_todos.index(selected)
                remaining_todos.pop(index)
                remaining_weights.pop(index)

        # Convert to response format
        return [
            TodoResponse(
                id=todo.id,
                task=todo.task,
                details=todo.details,
                status=PydanticTodoStatus(todo.status.value),
                date_created=todo.date_created,
                date_updated=todo.date_updated,
                user_id=todo.user_id,
                order=todo.order,
                priority=annotated_orders.get(todo.id),
                desirability=todo_desirability.get(todo.id),
                importance=Importance(todo.importance),
                time_estimate=PydanticTimeEstimate(todo.time_estimate.value)
                if todo.time_estimate
                else None,
                annoyingness=Annoyingness(todo.annoyingness),
                committed=todo.committed,
                elapsedTimeSeconds=int(todo.time_elapsed()),
                atomic=todo.atomic,
                infinitely_divisible=todo.infinitely_divisible,
            )
            for todo in selected_todos
        ]
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve weighted random todos: {str(e)}",
        )
