# FastAPI router for Fun endpoints

from typing import List
import uuid
from fastapi import APIRouter, HTTPException, status, Depends
from sqlalchemy.orm import Session
from app.auth import get_current_user
from app.autogenerated.pydantic_models import (
    Fun as FunResponse,
    CreateFunRequest,
    UpdateFunRequest,
    ReorderTodoRequest,
    ErrorResponse,
)
from app.models.fun import Fun as FunModel
from app.models.user import User as UserModel
from app.database import get_db

router = APIRouter(prefix="/api/funs", tags=["Funs"])


@router.get(
    "",
    response_model=List[FunResponse],
    status_code=status.HTTP_200_OK,
    responses={
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="List all funs for the authenticated user",
)
async def list_funs(
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> List[FunResponse]:
    """
    List all funs for the authenticated user.

    Returns:
        List[Fun]: List of all funs
    """
    funs = db.query(FunModel).filter(FunModel.user_id == current_user.id).order_by(FunModel.order).all()

    return [
        FunResponse(
            id=fun.id,
            title=fun.title,
            user_id=fun.user_id,
            order=fun.order,
            date_created=fun.date_created,
            date_updated=fun.date_updated,
        )
        for fun in funs
    ]


@router.post(
    "",
    response_model=FunResponse,
    status_code=status.HTTP_201_CREATED,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Create a new fun",
)
async def create_fun(
    fun: CreateFunRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> FunResponse:
    """
    Create a new fun.

    Args:
        fun: The fun data to create

    Returns:
        Fun: The created fun
    """
    from fractional_indexing import generate_key_between
    from app.autogenerated.pydantic_models import PositionTop, PositionBottom, PositionAfter

    # Generate a new UUID for the fun
    fun_id = str(uuid.uuid4())

    # Get ALL funs sorted by order to avoid conflicts
    all_funs = db.query(FunModel).filter(
        FunModel.user_id == current_user.id
    ).order_by(FunModel.order).all()

    # Calculate order based on position
    if fun.position:
        position_value = fun.position.root
        if isinstance(position_value, PositionTop):
            # Insert at the top
            first_order = all_funs[0].order if all_funs else None
            new_order = generate_key_between(None, first_order)
        elif isinstance(position_value, PositionBottom):
            # Insert at the bottom
            last_order = all_funs[-1].order if all_funs else None
            new_order = generate_key_between(last_order, None)
        elif isinstance(position_value, PositionAfter):
            # Insert after a specific fun
            after_index = next((i for i, f in enumerate(all_funs) if f.id == position_value.id), None)
            if after_index is None:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Fun with id {position_value.id} not found"
                )
            after_fun = all_funs[after_index]
            next_fun = all_funs[after_index + 1] if after_index + 1 < len(all_funs) else None
            new_order = generate_key_between(after_fun.order, next_fun.order if next_fun else None)
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid position type"
            )
    else:
        # Default to top
        first_order = all_funs[0].order if all_funs else None
        new_order = generate_key_between(None, first_order)

    # Create new fun
    db_fun = FunModel(
        id=fun_id,
        title=fun.title,
        user_id=current_user.id,
        order=new_order,
    )

    db.add(db_fun)
    db.commit()
    db.refresh(db_fun)

    return FunResponse(
        id=db_fun.id,
        title=db_fun.title,
        user_id=db_fun.user_id,
        order=db_fun.order,
        date_created=db_fun.date_created,
        date_updated=db_fun.date_updated,
    )


@router.get(
    "/{id}",
    response_model=FunResponse,
    status_code=status.HTTP_200_OK,
    responses={
        404: {"model": ErrorResponse, "description": "Fun not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Get a specific fun by ID",
)
async def get_fun(
    id: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> FunResponse:
    """
    Get a specific fun by ID.

    Args:
        id: The fun ID

    Returns:
        Fun: The requested fun

    Raises:
        HTTPException: 404 if fun not found
    """
    db_fun = db.query(FunModel).filter(
        FunModel.id == id,
        FunModel.user_id == current_user.id
    ).first()

    if not db_fun:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Fun with id {id} not found"
        )

    return FunResponse(
        id=db_fun.id,
        title=db_fun.title,
        user_id=db_fun.user_id,
        order=db_fun.order,
        date_created=db_fun.date_created,
        date_updated=db_fun.date_updated,
    )


@router.patch(
    "/{id}",
    response_model=FunResponse,
    status_code=status.HTTP_200_OK,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        404: {"model": ErrorResponse, "description": "Fun not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Update a fun",
)
async def update_fun(
    id: str,
    fun: UpdateFunRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> FunResponse:
    """
    Update a fun.

    Args:
        id: The fun ID
        fun: The updated fun data

    Returns:
        Fun: The updated fun

    Raises:
        HTTPException: 404 if fun not found
    """
    db_fun = db.query(FunModel).filter(
        FunModel.id == id,
        FunModel.user_id == current_user.id
    ).first()

    if not db_fun:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Fun with id {id} not found"
        )

    # Update only provided fields
    if fun.title is not None:
        db_fun.title = fun.title

    db.commit()
    db.refresh(db_fun)

    return FunResponse(
        id=db_fun.id,
        title=db_fun.title,
        user_id=db_fun.user_id,
        order=db_fun.order,
        date_created=db_fun.date_created,
        date_updated=db_fun.date_updated,
    )


@router.delete(
    "/{id}",
    status_code=status.HTTP_204_NO_CONTENT,
    responses={
        404: {"model": ErrorResponse, "description": "Fun not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Delete a fun",
)
async def delete_fun(
    id: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> None:
    """
    Delete a fun.

    Args:
        id: The fun ID

    Raises:
        HTTPException: 404 if fun not found
    """
    db_fun = db.query(FunModel).filter(
        FunModel.id == id,
        FunModel.user_id == current_user.id
    ).first()

    if not db_fun:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Fun with id {id} not found"
        )

    db.delete(db_fun)
    db.commit()


@router.post(
    "/{id}/reorder",
    response_model=FunResponse,
    status_code=status.HTTP_200_OK,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        404: {"model": ErrorResponse, "description": "Fun not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Reorder a fun",
)
async def reorder_fun(
    id: str,
    request: ReorderTodoRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> FunResponse:
    """
    Reorder a fun.

    Args:
        id: The fun ID
        request: The reorder request with position

    Returns:
        Fun: The reordered fun

    Raises:
        HTTPException: 404 if fun not found
    """
    from fractional_indexing import generate_key_between
    from app.autogenerated.pydantic_models import PositionTop, PositionBottom, PositionAfter

    # Find the fun to reorder
    db_fun = db.query(FunModel).filter(
        FunModel.id == id,
        FunModel.user_id == current_user.id
    ).first()

    if not db_fun:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Fun with id {id} not found"
        )

    # Get ALL funs sorted by order to avoid conflicts
    all_funs = db.query(FunModel).filter(
        FunModel.user_id == current_user.id
    ).order_by(FunModel.order).all()

    # Calculate new order based on position
    position_value = request.position.root
    if isinstance(position_value, PositionTop):
        # Move to the top
        first_order = all_funs[0].order if all_funs else None
        new_order = generate_key_between(None, first_order)
    elif isinstance(position_value, PositionBottom):
        # Move to the bottom
        last_order = all_funs[-1].order if all_funs else None
        new_order = generate_key_between(last_order, None)
    elif isinstance(position_value, PositionAfter):
        # Move after a specific fun
        after_index = next((i for i, f in enumerate(all_funs) if f.id == position_value.id), None)
        if after_index is None:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Fun with id {position_value.id} not found"
            )
        after_fun = all_funs[after_index]
        next_fun = all_funs[after_index + 1] if after_index + 1 < len(all_funs) else None
        new_order = generate_key_between(after_fun.order, next_fun.order if next_fun else None)
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid position type"
        )

    # Update the order
    db_fun.order = new_order

    db.commit()
    db.refresh(db_fun)

    return FunResponse(
        id=db_fun.id,
        title=db_fun.title,
        user_id=db_fun.user_id,
        order=db_fun.order,
        date_created=db_fun.date_created,
        date_updated=db_fun.date_updated,
    )
