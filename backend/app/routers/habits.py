# FastAPI router for Habit endpoints
# Generated from OpenAPI specification

from typing import List
import uuid
from datetime import datetime, timezone, timedelta
from fastapi import APIRouter, HTTPException, status, Depends
from sqlalchemy.orm import Session
from app.auth import get_current_user
from app.autogenerated.pydantic_models import (
    Habit as HabitResponse,
    CreateHabitRequest,
    UpdateHabitRequest,
    LogHabitRequest,
    ErrorResponse,
    TodoStatus as PydanticTodoStatus,
    TimeEstimate as PydanticTimeEstimate,
    Importance,
    Annoyingness,
    FrequencyKind as PydanticFrequencyKind,
)
from app.models.todo import Todo as TodoModel, TodoStatus, TimeEstimate, FrequencyKind, TodoKind, HabitLog
from app.models.desirability import calculate_desirabilities
from app.models.user import User as UserModel
from app.database import get_db

router = APIRouter(prefix="/api/habits", tags=["Habits"])


def get_done_this_week(db: Session, habit_id: str) -> List[int]:
    """Get the days of the week (0-6) when this habit was logged this week."""
    # Get the start of this week (Monday)
    now = datetime.now(timezone.utc)
    days_since_monday = now.weekday()  # Python's weekday() returns 0=Monday
    start_of_week = (now - timedelta(days=days_since_monday)).replace(hour=0, minute=0, second=0, microsecond=0)

    # Query habit logs for this week
    habit_logs = db.query(HabitLog).filter(
        HabitLog.habit_id == habit_id,
        HabitLog.when >= start_of_week.date()
    ).all()

    # Convert dates to day of week integers (0=Monday, 6=Sunday)
    done_days = []
    for log in habit_logs:
        # Python's weekday() returns 0=Monday, 6=Sunday
        # This is exactly what we want!
        done_days.append(log.when.weekday())

    return sorted(set(done_days))  # Remove duplicates and sort


def todo_to_habit_response(db: Session, todo: TodoModel, priority: int | None, desirability: float | None) -> HabitResponse:
    """Convert a Todo model to a Habit response."""
    return HabitResponse(
        id=todo.id,
        task=todo.task,
        details=todo.details,
        status=PydanticTodoStatus(todo.status.value),
        date_created=todo.date_created,
        date_updated=todo.date_updated,
        user_id=todo.user_id,
        order=todo.order,
        priority=priority,
        desirability=desirability,
        importance=Importance(todo.importance) if todo.importance is not None else None,
        time_estimate=PydanticTimeEstimate(todo.time_estimate.value) if todo.time_estimate else None,
        annoyingness=Annoyingness(todo.annoyingness),
        committed=todo.committed,
        elapsedTimeSeconds=int(todo.time_elapsed()),
        atomic=todo.atomic,
        infinitely_divisible=todo.infinitely_divisible,
        frequency_kind=PydanticFrequencyKind(todo.frequency_kind.value) if todo.frequency_kind else PydanticFrequencyKind.specific_days_per_week,
        days_of_week=todo.days_of_week,
        num_times_per_week=todo.num_times_per_week,
        num_times_per_month=todo.num_times_per_month,
        day_of_month=todo.day_of_month,
        done_this_week=get_done_this_week(db, todo.id),
    )


@router.get(
    "",
    response_model=List[HabitResponse],
    status_code=status.HTTP_200_OK,
    responses={
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="List all habits for the authenticated user",
)
async def list_habits(
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> List[HabitResponse]:
    """
    List all habits for the authenticated user.

    Returns:
        List[Habit]: List of all habits
    """
    habits = db.query(TodoModel).filter(
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).order_by(TodoModel.order).all()

    # Calculate desirability for all habits
    habit_desirabilities = calculate_desirabilities(habits)

    return [
        todo_to_habit_response(db, habit, i, habit_desirabilities.get(habit.id))
        for i, habit in enumerate(habits)
    ]


@router.post(
    "",
    response_model=HabitResponse,
    status_code=status.HTTP_201_CREATED,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Create a new habit",
)
async def create_habit(
    habit: CreateHabitRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> HabitResponse:
    """
    Create a new habit.

    Args:
        habit: The habit data to create

    Returns:
        Habit: The created habit
    """
    from fractional_indexing import generate_key_between
    from app.autogenerated.pydantic_models import PositionTop, PositionBottom, PositionAfter

    # Generate a new UUID for the habit
    habit_id = str(uuid.uuid4())

    # Get ALL habits sorted by order to avoid conflicts
    all_habits = db.query(TodoModel).filter(
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).order_by(TodoModel.order).all()

    # Calculate order based on position
    if habit.position:
        position_value = habit.position.root
        if isinstance(position_value, PositionTop):
            # Insert at the top
            first_order = all_habits[0].order if all_habits else None
            new_order = generate_key_between(None, first_order)
        elif isinstance(position_value, PositionBottom):
            # Insert at the bottom
            last_order = all_habits[-1].order if all_habits else None
            new_order = generate_key_between(last_order, None)
        elif isinstance(position_value, PositionAfter):
            # Insert after a specific habit
            after_index = next((i for i, h in enumerate(all_habits) if h.id == position_value.id), None)
            if after_index is None:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Habit with id {position_value.id} not found"
                )
            after_habit = all_habits[after_index]
            next_habit = all_habits[after_index + 1] if after_index + 1 < len(all_habits) else None
            new_order = generate_key_between(after_habit.order, next_habit.order if next_habit else None)
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid position type"
            )
    else:
        # Default to bottom (end of list)
        last_order = all_habits[-1].order if all_habits else None
        new_order = generate_key_between(last_order, None)

    # Convert Pydantic enums to SQLAlchemy enums
    db_status = TodoStatus(habit.status.value) if habit.status else TodoStatus.TODO
    db_time_estimate = TimeEstimate(habit.time_estimate.value) if habit.time_estimate else None
    db_frequency_kind = FrequencyKind(habit.frequency_kind.value)

    # Create new habit
    db_habit = TodoModel(
        id=habit_id,
        task=habit.task,
        details=habit.details,
        status=db_status,
        user_id=current_user.id,
        order=new_order,
        importance=habit.importance.root if habit.importance else 0,
        time_estimate=db_time_estimate,
        annoyingness=habit.annoyingness.root if habit.annoyingness else 0,
        committed=habit.committed or False,
        atomic=habit.atomic or False,
        infinitely_divisible=habit.infinitely_divisible or False,
        kind=TodoKind.HABIT,
        frequency_kind=db_frequency_kind,
        days_of_week=habit.days_of_week,
        num_times_per_week=habit.num_times_per_week,
        num_times_per_month=habit.num_times_per_month,
        day_of_month=habit.day_of_month,
    )

    db.add(db_habit)
    db.commit()
    db.refresh(db_habit)

    # Get all habits to calculate priority and desirability
    all_habits = db.query(TodoModel).filter(
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).order_by(TodoModel.order).all()
    habit_desirabilities = calculate_desirabilities(all_habits)

    # Find the priority (index) of the newly created habit
    priority = next((i for i, h in enumerate(all_habits) if h.id == db_habit.id), None)

    return todo_to_habit_response(db, db_habit, priority, habit_desirabilities.get(db_habit.id))


@router.get(
    "/{id}",
    response_model=HabitResponse,
    status_code=status.HTTP_200_OK,
    responses={
        404: {"model": ErrorResponse, "description": "Habit not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Get a specific habit by ID",
)
async def get_habit(
    id: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> HabitResponse:
    """
    Get a specific habit by ID.

    Args:
        id: The habit ID

    Returns:
        Habit: The requested habit

    Raises:
        HTTPException: 404 if habit not found
    """
    db_habit = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).first()

    if not db_habit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Habit with id {id} not found"
        )

    # Get all habits to calculate priority and desirability
    all_habits = db.query(TodoModel).filter(
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).order_by(TodoModel.order).all()
    habit_desirabilities = calculate_desirabilities(all_habits)

    # Find the priority (index) of the requested habit
    priority = next((i for i, h in enumerate(all_habits) if h.id == db_habit.id), None)

    return todo_to_habit_response(db, db_habit, priority, habit_desirabilities.get(db_habit.id))


@router.patch(
    "/{id}",
    response_model=HabitResponse,
    status_code=status.HTTP_200_OK,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        404: {"model": ErrorResponse, "description": "Habit not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Update a habit",
)
async def update_habit(
    id: str,
    habit: UpdateHabitRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> HabitResponse:
    """
    Update a habit.

    Args:
        id: The habit ID
        habit: The updated habit data

    Returns:
        Habit: The updated habit

    Raises:
        HTTPException: 404 if habit not found
    """
    db_habit = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).first()

    if not db_habit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Habit with id {id} not found"
        )

    # Update only provided fields
    if habit.task is not None:
        db_habit.task = habit.task
    if habit.details is not None:
        db_habit.details = habit.details
    if habit.status is not None:
        db_habit.status = TodoStatus(habit.status.value)
    if habit.importance is not None:
        db_habit.importance = habit.importance.root
    if habit.time_estimate is not None:
        db_habit.time_estimate = TimeEstimate(habit.time_estimate.value)
    if habit.annoyingness is not None:
        db_habit.annoyingness = habit.annoyingness.root
    if habit.committed is not None:
        db_habit.committed = habit.committed
    if habit.atomic is not None:
        db_habit.atomic = habit.atomic
    if habit.infinitely_divisible is not None:
        db_habit.infinitely_divisible = habit.infinitely_divisible
    if habit.frequency_kind is not None:
        db_habit.frequency_kind = FrequencyKind(habit.frequency_kind.value)
    if habit.days_of_week is not None:
        db_habit.days_of_week = habit.days_of_week
    if habit.num_times_per_week is not None:
        db_habit.num_times_per_week = habit.num_times_per_week
    if habit.num_times_per_month is not None:
        db_habit.num_times_per_month = habit.num_times_per_month
    if habit.day_of_month is not None:
        db_habit.day_of_month = habit.day_of_month

    db.commit()
    db.refresh(db_habit)

    # Get all habits to calculate priority and desirability
    all_habits = db.query(TodoModel).filter(
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).order_by(TodoModel.order).all()
    habit_desirabilities = calculate_desirabilities(all_habits)

    # Find the priority (index) of the updated habit
    priority = next((i for i, h in enumerate(all_habits) if h.id == db_habit.id), None)

    return todo_to_habit_response(db, db_habit, priority, habit_desirabilities.get(db_habit.id))


@router.delete(
    "/{id}",
    status_code=status.HTTP_204_NO_CONTENT,
    responses={
        404: {"model": ErrorResponse, "description": "Habit not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Delete a habit",
)
async def delete_habit(
    id: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> None:
    """
    Delete a habit.

    Args:
        id: The habit ID

    Raises:
        HTTPException: 404 if habit not found
    """
    db_habit = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).first()

    if not db_habit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Habit with id {id} not found"
        )

    db.delete(db_habit)
    db.commit()


@router.post(
    "/{id}/log",
    status_code=status.HTTP_200_OK,
    responses={
        404: {"model": ErrorResponse, "description": "Habit not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Log a habit completion",
)
async def log_habit(
    id: str,
    request: LogHabitRequest,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> None:
    """
    Log a habit completion.

    Creates a habit log entry with the specified date.

    Args:
        id: The habit ID
        request: The log request containing the date

    Raises:
        HTTPException: 404 if habit not found
    """
    from app.models.todo import HabitLog

    # Verify the habit exists and belongs to the user
    db_habit = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).first()

    if not db_habit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Habit with id {id} not found"
        )

    # Create a new habit log entry
    habit_log = HabitLog(
        id=str(uuid.uuid4()),
        habit_id=id,
        when=request.when
    )

    db.add(habit_log)
    db.commit()


@router.delete(
    "/{id}/log/{date}",
    status_code=status.HTTP_204_NO_CONTENT,
    responses={
        404: {"model": ErrorResponse, "description": "Habit log not found"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Delete a habit log entry",
)
async def delete_habit_log(
    id: str,
    date: str,
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> None:
    """
    Delete a habit log entry.

    Removes a habit log entry for the specified habit and date.

    Args:
        id: The habit ID
        date: The date of the log entry (YYYY-MM-DD format)

    Raises:
        HTTPException: 404 if habit or habit log not found
    """
    from app.models.todo import HabitLog
    from datetime import date as date_type

    # Verify the habit exists and belongs to the user
    db_habit = db.query(TodoModel).filter(
        TodoModel.id == id,
        TodoModel.user_id == current_user.id,
        TodoModel.frequency_kind.isnot(None)
    ).first()

    if not db_habit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Habit with id {id} not found"
        )

    # Parse the date string
    try:
        parsed_date = date_type.fromisoformat(date)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid date format: {date}. Expected YYYY-MM-DD"
        )

    # Find and delete the habit log entry
    habit_log = db.query(HabitLog).filter(
        HabitLog.habit_id == id,
        HabitLog.when == parsed_date
    ).first()

    if not habit_log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Habit log for habit {id} on date {date} not found"
        )

    db.delete(habit_log)
    db.commit()
