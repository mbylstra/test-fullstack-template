import uuid
from fastapi import APIRouter, HTTPException, status, Depends, Response, Request
from sqlalchemy.orm import Session

from app.auth import (
    get_current_user,
    create_access_token,
    create_refresh_token,
    decode_refresh_token,
    get_password_hash,
    verify_password,
)
from app.database import get_db
from app.autogenerated.pydantic_models import User as UserResponse, UserRegisterRequest, UserLoginRequest, Token, ErrorResponse
from app.models.user import User as UserModel

router = APIRouter(prefix='/api/auth', tags=['Authentication'])


@router.post(
    '/register',
    response_model=UserResponse,
    status_code=status.HTTP_201_CREATED,
    responses={
        400: {'model': ErrorResponse, 'description': 'Bad request'},
        500: {'model': ErrorResponse, 'description': 'Server error'},
    },
    summary='Register a new user',
)
async def register(user: UserRegisterRequest, db: Session = Depends(get_db)) -> UserResponse:
    """
    Register a new user with email and password.

    Args:
        user: User registration data
        db: Database session

    Returns:
        UserResponse: The created user

    Raises:
        HTTPException: 400 if email already registered
        HTTPException: 500 if server error occurs
    """
    try:
        existing_user = db.query(UserModel).filter(UserModel.email == user.email).first()
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail='Email already registered'
            )

        user_id = str(uuid.uuid4())
        hashed_password = get_password_hash(user.password)

        db_user = UserModel(
            id=user_id,
            email=user.email,
            hashed_password=hashed_password,
            is_active=True,
        )

        db.add(db_user)
        db.commit()
        db.refresh(db_user)

        return UserResponse(
            id=db_user.id,
            email=db_user.email,
            is_active=db_user.is_active,
            date_created=db_user.date_created,
            date_updated=db_user.date_updated,
        )
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f'Failed to register user: {str(e)}'
        )


@router.post(
    '/login',
    response_model=Token,
    status_code=status.HTTP_200_OK,
    responses={
        401: {'model': ErrorResponse, 'description': 'Unauthorized'},
        500: {'model': ErrorResponse, 'description': 'Server error'},
    },
    summary='Login with email and password',
)
async def login(
    credentials: UserLoginRequest,
    response: Response,
    db: Session = Depends(get_db),
) -> Token:
    """
    Login with email and password to get a JWT token.

    Args:
        credentials: User login credentials
        response: Response object to set cookies
        db: Database session

    Returns:
        Token: JWT access token with refresh token in httpOnly cookie

    Raises:
        HTTPException: 401 if credentials are invalid
        HTTPException: 500 if server error occurs
    """
    try:
        user = db.query(UserModel).filter(UserModel.email == credentials.email).first()

        if not user or not verify_password(credentials.password, user.hashed_password):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail='Incorrect email or password',
                headers={'WWW-Authenticate': 'Bearer'},
            )

        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail='Inactive user',
                headers={'WWW-Authenticate': 'Bearer'},
            )

        access_token = create_access_token(data={'sub': user.id})
        refresh_token = create_refresh_token(data={'sub': user.id})

        response.set_cookie(
            key='refresh_token',
            value=refresh_token,
            httponly=True,
            secure=True,
            samesite='lax',
            max_age=7 * 24 * 60 * 60,  # 7 days
        )

        return Token(
            access_token=access_token,
            token_type='bearer'
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f'Failed to login: {str(e)}'
        )


@router.get(
    '/me',
    response_model=UserResponse,
    status_code=status.HTTP_200_OK,
    responses={
        401: {'model': ErrorResponse, 'description': 'Unauthorized'},
        500: {'model': ErrorResponse, 'description': 'Server error'},
    },
    summary='Get current authenticated user',
)
async def get_me(current_user: UserModel = Depends(get_current_user)) -> UserResponse:
    """
    Get the current authenticated user.

    Args:
        current_user: The authenticated user from JWT token

    Returns:
        UserResponse: The current user

    Raises:
        HTTPException: 401 if not authenticated
        HTTPException: 500 if server error occurs
    """
    return UserResponse(
        id=current_user.id,
        email=current_user.email,
        is_active=current_user.is_active,
        date_created=current_user.date_created,
        date_updated=current_user.date_updated,
    )


@router.post(
    '/refresh',
    response_model=Token,
    status_code=status.HTTP_200_OK,
    responses={
        401: {'model': ErrorResponse, 'description': 'Unauthorized'},
        500: {'model': ErrorResponse, 'description': 'Server error'},
    },
    summary='Refresh access token using refresh token',
)
async def refresh(
    request: Request,
    response: Response,
    db: Session = Depends(get_db),
) -> Token:
    """
    Refresh the access token using the refresh token from httpOnly cookie.

    Args:
        request: Request object containing cookies
        response: Response object to set new cookie
        db: Database session

    Returns:
        Token: New access token

    Raises:
        HTTPException: 401 if refresh token is invalid or missing
        HTTPException: 500 if server error occurs
    """
    try:
        refresh_token = request.cookies.get('refresh_token')

        if not refresh_token:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail='Refresh token missing',
            )

        payload = decode_refresh_token(refresh_token)
        if not payload:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail='Invalid or expired refresh token',
            )

        user_id = payload.get('sub')
        if not user_id or not isinstance(user_id, str):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail='Invalid refresh token',
            )

        user = db.query(UserModel).filter(UserModel.id == user_id).first()
        if not user or not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail='User not found or inactive',
            )

        new_access_token = create_access_token(data={'sub': user.id})
        new_refresh_token = create_refresh_token(data={'sub': user.id})

        response.set_cookie(
            key='refresh_token',
            value=new_refresh_token,
            httponly=True,
            secure=True,
            samesite='lax',
            max_age=7 * 24 * 60 * 60,
        )

        return Token(
            access_token=new_access_token,
            token_type='bearer'
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f'Failed to refresh token: {str(e)}'
        )


@router.post(
    '/logout',
    status_code=status.HTTP_200_OK,
    responses={
        401: {'model': ErrorResponse, 'description': 'Unauthorized'},
    },
    summary='Logout user',
)
async def logout(response: Response) -> dict:
    """
    Logout user by clearing the refresh token cookie.

    Args:
        response: Response object to clear cookies

    Returns:
        dict: Success message
    """
    response.delete_cookie(key='refresh_token', httponly=True, secure=True, samesite='lax')
    return {'message': 'Logged out successfully'}
