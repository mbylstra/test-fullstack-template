# FastAPI router for weighted random funs endpoint
import random
from typing import List, Optional
from fastapi import APIRouter, HTTPException, status, Depends, Query
from sqlalchemy.orm import Session
from app.auth import get_current_user
from app.autogenerated.pydantic_models import (
    Fun as FunResponse,
    ErrorResponse,
)
from app.models.fun import Fun as FunModel
from app.models.user import User as UserModel
from app.database import get_db

router = APIRouter(prefix="/api/weighted-random-funs", tags=["Funs"])


def calculate_weights(funs: List[FunModel]) -> List[float]:
    """
    Calculate weights for funs based on their position in the list.
    Items at the top have higher weight.

    The weight formula uses exponential decay: weight = exp(-position * decay_factor)
    This creates a strong bias toward items at the top of the list.
    """
    if not funs:
        return []

    # Decay factor controls how quickly weights decrease
    # Higher decay = more weight toward the top
    decay_factor = 0.15

    weights = []
    for index in range(len(funs)):
        # Exponential decay based on position
        weight = 2.71828 ** (-index * decay_factor)
        weights.append(weight)

    return weights


@router.get(
    "",
    response_model=List[FunResponse],
    status_code=status.HTTP_200_OK,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
    summary="Get weighted random funs for the authenticated user",
)
async def list_weighted_random_funs(
    n: int,
    exclude_ids: Optional[str] = Query(None, alias="excludeIds"),
    current_user: UserModel = Depends(get_current_user),
    db: Session = Depends(get_db),
) -> List[FunResponse]:
    """
    Get weighted random funs for the authenticated user.

    Uses weighted random selection based on position in the list.
    Items at the top of the list have higher weights.

    Args:
        n: Number of funs to return
        exclude_ids: List of fun IDs to exclude from selection

    Returns:
        List[Fun]: List of weighted random funs

    Raises:
        HTTPException: 400 if n is invalid
        HTTPException: 500 if server error occurs
    """
    try:
        if n < 1:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Parameter 'n' must be at least 1",
            )

        # Get all funs for the user ordered by their position
        query = (
            db.query(FunModel)
            .filter(FunModel.user_id == current_user.id)
            .order_by(FunModel.order)
        )

        all_funs = query.all()

        # Filter out excluded IDs
        if exclude_ids:
            # Parse comma-separated string into list
            excluded_id_list = [id.strip() for id in exclude_ids.split(',') if id.strip()]
            funs_to_choose_from = [fun for fun in all_funs if fun.id not in excluded_id_list]
        else:
            funs_to_choose_from = all_funs

        # If there are no funs to choose from, return empty list
        if not funs_to_choose_from:
            return []

        # Calculate weights based on position
        weights = calculate_weights(funs_to_choose_from)

        # Select funs without replacement (no duplicates)
        if n >= len(funs_to_choose_from):
            selected_funs = funs_to_choose_from
        else:
            # Perform weighted random selection without replacement
            selected_funs = []
            remaining_funs = list(funs_to_choose_from)
            remaining_weights = list(weights)

            for _ in range(n):
                # Select one fun using weighted random
                selected = random.choices(remaining_funs, weights=remaining_weights, k=1)[0]
                selected_funs.append(selected)

                # Remove the selected fun and its weight to prevent duplicates
                index = remaining_funs.index(selected)
                remaining_funs.pop(index)
                remaining_weights.pop(index)

        # Convert to response format
        return [
            FunResponse(
                id=fun.id,
                title=fun.title,
                user_id=fun.user_id,
                order=fun.order,
                date_created=fun.date_created,
                date_updated=fun.date_updated,
            )
            for fun in selected_funs
        ]
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve weighted random funs: {str(e)}",
        )
