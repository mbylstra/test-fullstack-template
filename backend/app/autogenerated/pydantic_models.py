# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-12-20T03:36:45+00:00

from __future__ import annotations

from datetime import date
from enum import Enum
from typing import Annotated, Any, Dict, List, Optional, Union

from pydantic import AwareDatetime, BaseModel, ConfigDict, Field, RootModel


class Annoyingness(RootModel[int]):
    root: Annotated[int, Field(description='Annoyingness level (0-4)', ge=0, le=4)]


class ErrorResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    message: Annotated[str, Field(description='Error message')]
    code: Annotated[Optional[str], Field(description='Error code')] = None


class FrequencyKind(Enum):
    specific_days_per_week = 'specific-days-per-week'
    multiple_days_per_week = 'multiple-days-per-week'
    specific_day_of_month = 'specific-day-of-month'
    multiple_days_per_month = 'multiple-days-per-month'


class Fun(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='Unique identifier for the fun')]
    title: Annotated[str, Field(description='The fun title')]
    user_id: Annotated[str, Field(description='ID of the user who owns this fun')]
    order: Annotated[str, Field(description='Order/position of the fun in the list')]
    date_created: Annotated[
        AwareDatetime, Field(description='When the fun was created')
    ]
    date_updated: Annotated[
        AwareDatetime, Field(description='When the fun was last updated')
    ]


class Importance(RootModel[int]):
    root: Annotated[int, Field(description='Importance level (0-5)', ge=0, le=5)]


class LogHabitRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    when: Annotated[
        date,
        Field(description='The date when the habit was completed (YYYY-MM-DD format)'),
    ]


class OverrideElapsedTimeRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    hours: Annotated[int, Field(description='Hours component of elapsed time')]
    minutes: Annotated[int, Field(description='Minutes component of elapsed time')]


class Type(Enum):
    after = 'after'


class PositionAfter(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type
    id: Annotated[str, Field(description='ID of the todo to insert after')]


class Type1(Enum):
    bottom = 'bottom'


class PositionBottom(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type1


class Type2(Enum):
    top = 'top'


class PositionTop(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type2


class TimeEstimate(Enum):
    field_1_min = '1-min'
    field_5_mins = '5-mins'
    field_15_mins = '15-mins'
    field_30_mins = '30-mins'
    field_1_hour = '1-hour'
    field_2_hours = '2-hours'
    half_day = 'half-day'
    one_day = 'one-day'
    project = 'project'


class TodoPosition(RootModel[Union[PositionTop, PositionBottom, PositionAfter]]):
    root: Annotated[
        Union[PositionTop, PositionBottom, PositionAfter],
        Field(description='Position for inserting a new todo'),
    ]


class TodoStatus(Enum):
    todo = 'todo'
    complete = 'complete'
    archived = 'archived'
    waiting = 'waiting'


class Token(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    access_token: Annotated[str, Field(description='JWT access token')]
    token_type: Annotated[str, Field(description="Token type (always 'bearer')")]


class UpdateFunRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    title: Annotated[Optional[str], Field(description='The fun title')] = None


class UpdateHabitRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    task: Annotated[Optional[str], Field(description='The habit description')] = None
    details: Annotated[
        Optional[Dict[str, Any]], Field(description='Additional details stored as JSON')
    ] = None
    status: Annotated[
        Optional[TodoStatus], Field(description='Current status of the habit')
    ] = None
    importance: Annotated[
        Optional[Importance], Field(description='Importance level (0-5)')
    ] = None
    time_estimate: Annotated[
        Optional[TimeEstimate], Field(description='Estimated time to complete')
    ] = None
    annoyingness: Annotated[
        Optional[Annoyingness], Field(description='Annoyingness level (0-4)')
    ] = None
    committed: Annotated[
        Optional[bool], Field(description='Whether the habit is committed')
    ] = None
    atomic: Annotated[
        Optional[bool], Field(description='Whether the habit is atomic')
    ] = None
    infinitely_divisible: Annotated[
        Optional[bool], Field(description='Whether the habit is infinitely divisible')
    ] = None
    frequency_kind: Annotated[
        Optional[FrequencyKind],
        Field(
            description="Frequency kind for recurring habits\nConstraints:\n- If 'specific-days-per-week', daysOfWeek must be provided\n- If 'multiple-days-per-week', numTimesPerWeek must be provided\n- If 'specific-day-of-month', dayOfMonth must be provided\n- If 'multiple-days-per-month', numTimesPerMonth must be provided"
        ),
    ] = None
    days_of_week: Annotated[
        Optional[List[int]],
        Field(
            description="Days of the week (0-6, where 0=Monday, 6=Sunday)\nRequired when frequencyKind is 'specific-days-per-week'"
        ),
    ] = None
    num_times_per_week: Annotated[
        Optional[int],
        Field(
            description="Number of times per week\nRequired when frequencyKind is 'multiple-days-per-week'"
        ),
    ] = None
    num_times_per_month: Annotated[
        Optional[int],
        Field(
            description="Number of times per month\nRequired when frequencyKind is 'multiple-days-per-month'"
        ),
    ] = None
    day_of_month: Annotated[
        Optional[int],
        Field(
            description="Day of the month (1-31)\nRequired when frequencyKind is 'specific-day-of-month'"
        ),
    ] = None


class UpdateTodoRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    task: Annotated[Optional[str], Field(description='The task description')] = None
    details: Annotated[
        Optional[Dict[str, Any]], Field(description='Additional details stored as JSON')
    ] = None
    status: Annotated[
        Optional[TodoStatus], Field(description='Current status of the todo')
    ] = None
    importance: Annotated[
        Optional[Importance], Field(description='Importance level (0-5)')
    ] = None
    time_estimate: Annotated[
        Optional[TimeEstimate], Field(description='Estimated time to complete')
    ] = None
    annoyingness: Annotated[
        Optional[Annoyingness], Field(description='Annoyingness level (0-4)')
    ] = None
    committed: Annotated[
        Optional[bool], Field(description='Whether the todo is committed')
    ] = None
    atomic: Annotated[
        Optional[bool], Field(description='Whether the todo is atomic')
    ] = None
    infinitely_divisible: Annotated[
        Optional[bool], Field(description='Whether the todo is infinitely divisible')
    ] = None


class User(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='Unique identifier for the user')]
    email: Annotated[str, Field(description="User's email address")]
    is_active: Annotated[bool, Field(description='Whether the user account is active')]
    date_created: Annotated[
        AwareDatetime, Field(description='When the user was created')
    ]
    date_updated: Annotated[
        AwareDatetime, Field(description='When the user was last updated')
    ]


class UserLoginRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email: Annotated[str, Field(description="User's email address")]
    password: Annotated[str, Field(description="User's password")]


class UserRegisterRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email: Annotated[str, Field(description="User's email address")]
    password: Annotated[str, Field(description="User's password")]


class CreateFunRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    title: Annotated[str, Field(description='The fun title')]
    position: Annotated[
        Optional[TodoPosition],
        Field(description='Where to insert the fun (defaults to top)'),
    ] = None


class CreateHabitRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    task: Annotated[str, Field(description='The habit description')]
    details: Annotated[
        Optional[Dict[str, Any]], Field(description='Additional details stored as JSON')
    ] = None
    status: Annotated[
        Optional[TodoStatus],
        Field(description="Current status of the habit (defaults to 'todo')"),
    ] = None
    position: Annotated[
        Optional[TodoPosition],
        Field(description='Where to insert the habit (defaults to top)'),
    ] = None
    importance: Annotated[
        Optional[Importance], Field(description='Importance level (0-5)')
    ] = None
    time_estimate: Annotated[
        Optional[TimeEstimate], Field(description='Estimated time to complete')
    ] = None
    annoyingness: Annotated[
        Optional[Annoyingness], Field(description='Annoyingness level (0-4)')
    ] = None
    committed: Annotated[
        Optional[bool],
        Field(description='Whether the habit is committed (defaults to false)'),
    ] = None
    atomic: Annotated[
        Optional[bool],
        Field(description='Whether the habit is atomic (defaults to false)'),
    ] = None
    infinitely_divisible: Annotated[
        Optional[bool],
        Field(
            description='Whether the habit is infinitely divisible (defaults to false)'
        ),
    ] = None
    frequency_kind: Annotated[
        FrequencyKind,
        Field(
            description="Frequency kind for recurring habits\nConstraints:\n- If 'specific-days-per-week', daysOfWeek must be provided\n- If 'multiple-days-per-week', numTimesPerWeek must be provided\n- If 'specific-day-of-month', dayOfMonth must be provided\n- If 'multiple-days-per-month', numTimesPerMonth must be provided"
        ),
    ]
    days_of_week: Annotated[
        Optional[List[int]],
        Field(
            description="Days of the week (0-6, where 0=Monday, 6=Sunday)\nRequired when frequencyKind is 'specific-days-per-week'"
        ),
    ] = None
    num_times_per_week: Annotated[
        Optional[int],
        Field(
            description="Number of times per week\nRequired when frequencyKind is 'multiple-days-per-week'"
        ),
    ] = None
    num_times_per_month: Annotated[
        Optional[int],
        Field(
            description="Number of times per month\nRequired when frequencyKind is 'multiple-days-per-month'"
        ),
    ] = None
    day_of_month: Annotated[
        Optional[int],
        Field(
            description="Day of the month (1-31)\nRequired when frequencyKind is 'specific-day-of-month'"
        ),
    ] = None


class CreateTodoRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    task: Annotated[str, Field(description='The task description')]
    details: Annotated[
        Optional[Dict[str, Any]], Field(description='Additional details stored as JSON')
    ] = None
    status: Annotated[
        Optional[TodoStatus],
        Field(description="Current status of the todo (defaults to 'todo')"),
    ] = None
    position: Annotated[
        Optional[TodoPosition],
        Field(description='Where to insert the todo (defaults to top)'),
    ] = None
    importance: Annotated[
        Optional[Importance], Field(description='Importance level (0-5)')
    ] = None
    time_estimate: Annotated[
        Optional[TimeEstimate], Field(description='Estimated time to complete')
    ] = None
    annoyingness: Annotated[
        Optional[Annoyingness], Field(description='Annoyingness level (0-4)')
    ] = None
    committed: Annotated[
        Optional[bool],
        Field(description='Whether the todo is committed (defaults to false)'),
    ] = None
    atomic: Annotated[
        Optional[bool],
        Field(description='Whether the todo is atomic (defaults to false)'),
    ] = None
    infinitely_divisible: Annotated[
        Optional[bool],
        Field(
            description='Whether the todo is infinitely divisible (defaults to false)'
        ),
    ] = None


class Habit(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='Unique identifier for the habit')]
    task: Annotated[str, Field(description='The habit description')]
    details: Annotated[
        Optional[Dict[str, Any]], Field(description='Additional details stored as JSON')
    ] = None
    status: Annotated[TodoStatus, Field(description='Current status of the habit')]
    date_created: Annotated[
        AwareDatetime, Field(description='When the habit was created')
    ]
    date_updated: Annotated[
        AwareDatetime, Field(description='When the habit was last updated')
    ]
    user_id: Annotated[str, Field(description='ID of the user who owns this habit')]
    order: Annotated[str, Field(description='Order/position of the habit in the list')]
    priority: Annotated[
        Optional[int],
        Field(
            description='Integer priority position (0-based index in the ordered list)'
        ),
    ] = None
    desirability: Annotated[
        Optional[float],
        Field(
            description='Calculated desirability score for weighted random selection'
        ),
    ] = None
    importance: Annotated[
        Optional[Importance], Field(description='Importance level (0-5)')
    ] = None
    time_estimate: Annotated[
        Optional[TimeEstimate], Field(description='Estimated time to complete')
    ] = None
    annoyingness: Annotated[Annoyingness, Field(description='Annoyingness level (0-4)')]
    committed: Annotated[bool, Field(description='Whether the habit is committed')]
    elapsedTimeSeconds: Annotated[
        int, Field(description='Elapsed time in seconds for timer')
    ]
    atomic: Annotated[
        bool, Field(description='Whether the habit is atomic (cannot be broken down)')
    ]
    infinitely_divisible: Annotated[
        bool, Field(description='Whether the habit is infinitely divisible')
    ]
    frequency_kind: Annotated[
        FrequencyKind,
        Field(
            description="Frequency kind for recurring habits\nConstraints:\n- If 'specific-days-per-week', daysOfWeek must be provided\n- If 'multiple-days-per-week', numTimesPerWeek must be provided\n- If 'specific-day-of-month', dayOfMonth must be provided\n- If 'multiple-days-per-month', numTimesPerMonth must be provided"
        ),
    ]
    days_of_week: Annotated[
        Optional[List[int]],
        Field(
            description="Days of the week (0-6, where 0=Monday, 6=Sunday)\nRequired when frequencyKind is 'specific-days-per-week'"
        ),
    ] = None
    num_times_per_week: Annotated[
        Optional[int],
        Field(
            description="Number of times per week\nRequired when frequencyKind is 'multiple-days-per-week'"
        ),
    ] = None
    num_times_per_month: Annotated[
        Optional[int],
        Field(
            description="Number of times per month\nRequired when frequencyKind is 'multiple-days-per-month'"
        ),
    ] = None
    day_of_month: Annotated[
        Optional[int],
        Field(
            description="Day of the month (1-31)\nRequired when frequencyKind is 'specific-day-of-month'"
        ),
    ] = None
    done_this_week: Annotated[
        List[int],
        Field(
            description='Days of the week when habit was completed this week (0-6, where 0=Monday, 6=Sunday)'
        ),
    ]


class ReorderTodoRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    position: Annotated[TodoPosition, Field(description='New position for the todo')]


class Todo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='Unique identifier for the todo')]
    task: Annotated[str, Field(description='The task description')]
    details: Annotated[
        Optional[Dict[str, Any]], Field(description='Additional details stored as JSON')
    ] = None
    status: Annotated[TodoStatus, Field(description='Current status of the todo')]
    date_created: Annotated[
        AwareDatetime, Field(description='When the todo was created')
    ]
    date_updated: Annotated[
        AwareDatetime, Field(description='When the todo was last updated')
    ]
    user_id: Annotated[str, Field(description='ID of the user who owns this todo')]
    order: Annotated[str, Field(description='Order/position of the todo in the list')]
    priority: Annotated[
        Optional[int],
        Field(
            description='Integer priority position (0-based index in the ordered list)'
        ),
    ] = None
    desirability: Annotated[
        Optional[float],
        Field(
            description='Calculated desirability score for weighted random selection'
        ),
    ] = None
    importance: Annotated[
        Optional[Importance], Field(description='Importance level (0-5)')
    ] = None
    time_estimate: Annotated[
        Optional[TimeEstimate], Field(description='Estimated time to complete')
    ] = None
    annoyingness: Annotated[Annoyingness, Field(description='Annoyingness level (0-4)')]
    committed: Annotated[bool, Field(description='Whether the todo is committed')]
    elapsedTimeSeconds: Annotated[
        int, Field(description='Elapsed time in seconds for timer')
    ]
    atomic: Annotated[
        bool, Field(description='Whether the todo is atomic (cannot be broken down)')
    ]
    infinitely_divisible: Annotated[
        bool, Field(description='Whether the todo is infinitely divisible')
    ]
